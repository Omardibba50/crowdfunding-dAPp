import { TypedEventEmitter } from '@libp2p/interface';
import { Libp2pRecord } from '@libp2p/record';
import { AdaptiveTimeout } from '@libp2p/utils/adaptive-timeout';
import { pbStream } from 'it-protobuf-stream';
import { CodeError } from 'protons-runtime';
import { Message } from './message/dht.js';
import { fromPbPeerInfo } from './message/utils.js';
import { dialPeerEvent, sendQueryEvent, peerResponseEvent, queryErrorEvent } from './query/events.js';
/**
 * Handle network operations for the dht
 */
export class Network extends TypedEventEmitter {
    log;
    protocol;
    running;
    components;
    timeout;
    /**
     * Create a new network
     */
    constructor(components, init) {
        super();
        const { protocol } = init;
        this.components = components;
        this.log = components.logger.forComponent(`${init.logPrefix}:network`);
        this.running = false;
        this.protocol = protocol;
        this.timeout = new AdaptiveTimeout({
            ...(init.timeout ?? {}),
            metrics: components.metrics,
            metricName: `${init.logPrefix.replaceAll(':', '_')}_network_message_send_times_milliseconds`
        });
    }
    /**
     * Start the network
     */
    async start() {
        if (this.running) {
            return;
        }
        this.running = true;
    }
    /**
     * Stop all network activity
     */
    async stop() {
        this.running = false;
    }
    /**
     * Is the network online?
     */
    isStarted() {
        return this.running;
    }
    /**
     * Send a request and record RTT for latency measurements
     */
    async *sendRequest(to, msg, options = {}) {
        if (!this.running) {
            return;
        }
        const type = msg.type;
        if (type == null) {
            throw new CodeError('Message type was missing', 'ERR_INVALID_PARAMETERS');
        }
        this.log('sending %s to %p', msg.type, to);
        yield dialPeerEvent({ peer: to }, options);
        yield sendQueryEvent({ to, type }, options);
        let stream;
        const signal = this.timeout.getTimeoutSignal(options);
        options = {
            ...options,
            signal
        };
        try {
            const connection = await this.components.connectionManager.openConnection(to, options);
            stream = await connection.newStream(this.protocol, options);
            const response = await this._writeReadMessage(stream, msg, options);
            stream.close(options)
                .catch(err => {
                this.log.error('error closing stream to %p', to, err);
                stream?.abort(err);
            });
            yield peerResponseEvent({
                from: to,
                messageType: response.type,
                closer: response.closer.map(fromPbPeerInfo),
                providers: response.providers.map(fromPbPeerInfo),
                record: response.record == null ? undefined : Libp2pRecord.deserialize(response.record)
            }, options);
        }
        catch (err) {
            stream?.abort(err);
            this.log.error('could not send %s to %p', msg.type, to, err);
            yield queryErrorEvent({ from: to, error: err }, options);
        }
        finally {
            this.timeout.cleanUp(signal);
        }
    }
    /**
     * Sends a message without expecting an answer
     */
    async *sendMessage(to, msg, options = {}) {
        if (!this.running) {
            return;
        }
        const type = msg.type;
        if (type == null) {
            throw new CodeError('Message type was missing', 'ERR_INVALID_PARAMETERS');
        }
        this.log('sending %s to %p', msg.type, to);
        yield dialPeerEvent({ peer: to }, options);
        yield sendQueryEvent({ to, type }, options);
        let stream;
        const signal = this.timeout.getTimeoutSignal(options);
        options = {
            ...options,
            signal
        };
        try {
            const connection = await this.components.connectionManager.openConnection(to, options);
            stream = await connection.newStream(this.protocol, options);
            await this._writeMessage(stream, msg, options);
            stream.close(options)
                .catch(err => {
                this.log.error('error closing stream to %p', to, err);
                stream?.abort(err);
            });
            yield peerResponseEvent({ from: to, messageType: type }, options);
        }
        catch (err) {
            stream?.abort(err);
            yield queryErrorEvent({ from: to, error: err }, options);
        }
        finally {
            this.timeout.cleanUp(signal);
        }
    }
    /**
     * Write a message to the given stream
     */
    async _writeMessage(stream, msg, options) {
        const pb = pbStream(stream);
        await pb.write(msg, Message, options);
        await pb.unwrap().close(options);
    }
    /**
     * Write a message and read its response.
     * If no response is received after the specified timeout
     * this will error out.
     */
    async _writeReadMessage(stream, msg, options) {
        const pb = pbStream(stream);
        await pb.write(msg, Message, options);
        const message = await pb.read(Message, options);
        await pb.unwrap().close(options);
        // tell any listeners about new peers we've seen
        message.closer.forEach(peerData => {
            this.safeDispatchEvent('peer', {
                detail: fromPbPeerInfo(peerData)
            });
        });
        message.providers.forEach(peerData => {
            this.safeDispatchEvent('peer', {
                detail: fromPbPeerInfo(peerData)
            });
        });
        return message;
    }
}
//# sourceMappingURL=network.js.map