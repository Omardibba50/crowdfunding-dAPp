/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { decodeMessage, encodeMessage, enumeration, message } from 'protons-runtime';
import { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc';
export var Record;
(function (Record) {
    let _codec;
    Record.codec = () => {
        if (_codec == null) {
            _codec = message((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.key != null) {
                    w.uint32(10);
                    w.bytes(obj.key);
                }
                if (obj.value != null) {
                    w.uint32(18);
                    w.bytes(obj.value);
                }
                if (obj.author != null) {
                    w.uint32(26);
                    w.bytes(obj.author);
                }
                if (obj.signature != null) {
                    w.uint32(34);
                    w.bytes(obj.signature);
                }
                if (obj.timeReceived != null) {
                    w.uint32(42);
                    w.string(obj.timeReceived);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.key = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.value = reader.bytes();
                            break;
                        }
                        case 3: {
                            obj.author = reader.bytes();
                            break;
                        }
                        case 4: {
                            obj.signature = reader.bytes();
                            break;
                        }
                        case 5: {
                            obj.timeReceived = reader.string();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    Record.encode = (obj) => {
        return encodeMessage(obj, Record.codec());
    };
    Record.decode = (buf) => {
        return decodeMessage(buf, Record.codec());
    };
})(Record || (Record = {}));
export var MessageType;
(function (MessageType) {
    MessageType["PUT_VALUE"] = "PUT_VALUE";
    MessageType["GET_VALUE"] = "GET_VALUE";
    MessageType["ADD_PROVIDER"] = "ADD_PROVIDER";
    MessageType["GET_PROVIDERS"] = "GET_PROVIDERS";
    MessageType["FIND_NODE"] = "FIND_NODE";
    MessageType["PING"] = "PING";
})(MessageType || (MessageType = {}));
var __MessageTypeValues;
(function (__MessageTypeValues) {
    __MessageTypeValues[__MessageTypeValues["PUT_VALUE"] = 0] = "PUT_VALUE";
    __MessageTypeValues[__MessageTypeValues["GET_VALUE"] = 1] = "GET_VALUE";
    __MessageTypeValues[__MessageTypeValues["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    __MessageTypeValues[__MessageTypeValues["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    __MessageTypeValues[__MessageTypeValues["FIND_NODE"] = 4] = "FIND_NODE";
    __MessageTypeValues[__MessageTypeValues["PING"] = 5] = "PING";
})(__MessageTypeValues || (__MessageTypeValues = {}));
(function (MessageType) {
    MessageType.codec = () => {
        return enumeration(__MessageTypeValues);
    };
})(MessageType || (MessageType = {}));
export var ConnectionType;
(function (ConnectionType) {
    ConnectionType["NOT_CONNECTED"] = "NOT_CONNECTED";
    ConnectionType["CONNECTED"] = "CONNECTED";
    ConnectionType["CAN_CONNECT"] = "CAN_CONNECT";
    ConnectionType["CANNOT_CONNECT"] = "CANNOT_CONNECT";
})(ConnectionType || (ConnectionType = {}));
var __ConnectionTypeValues;
(function (__ConnectionTypeValues) {
    __ConnectionTypeValues[__ConnectionTypeValues["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
    __ConnectionTypeValues[__ConnectionTypeValues["CONNECTED"] = 1] = "CONNECTED";
    __ConnectionTypeValues[__ConnectionTypeValues["CAN_CONNECT"] = 2] = "CAN_CONNECT";
    __ConnectionTypeValues[__ConnectionTypeValues["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
})(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
(function (ConnectionType) {
    ConnectionType.codec = () => {
        return enumeration(__ConnectionTypeValues);
    };
})(ConnectionType || (ConnectionType = {}));
export var PeerInfo;
(function (PeerInfo) {
    let _codec;
    PeerInfo.codec = () => {
        if (_codec == null) {
            _codec = message((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.id != null && obj.id.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.id);
                }
                if (obj.multiaddrs != null) {
                    for (const value of obj.multiaddrs) {
                        w.uint32(18);
                        w.bytes(value);
                    }
                }
                if (obj.connection != null) {
                    w.uint32(24);
                    ConnectionType.codec().encode(obj.connection, w);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length) => {
                const obj = {
                    id: uint8ArrayAlloc(0),
                    multiaddrs: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.id = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.multiaddrs.push(reader.bytes());
                            break;
                        }
                        case 3: {
                            obj.connection = ConnectionType.codec().decode(reader);
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    PeerInfo.encode = (obj) => {
        return encodeMessage(obj, PeerInfo.codec());
    };
    PeerInfo.decode = (buf) => {
        return decodeMessage(buf, PeerInfo.codec());
    };
})(PeerInfo || (PeerInfo = {}));
export var Message;
(function (Message) {
    let _codec;
    Message.codec = () => {
        if (_codec == null) {
            _codec = message((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.type != null && __MessageTypeValues[obj.type] !== 0) {
                    w.uint32(8);
                    MessageType.codec().encode(obj.type, w);
                }
                if (obj.clusterLevel != null) {
                    w.uint32(80);
                    w.int32(obj.clusterLevel);
                }
                if (obj.key != null) {
                    w.uint32(18);
                    w.bytes(obj.key);
                }
                if (obj.record != null) {
                    w.uint32(26);
                    w.bytes(obj.record);
                }
                if (obj.closer != null) {
                    for (const value of obj.closer) {
                        w.uint32(66);
                        PeerInfo.codec().encode(value, w);
                    }
                }
                if (obj.providers != null) {
                    for (const value of obj.providers) {
                        w.uint32(74);
                        PeerInfo.codec().encode(value, w);
                    }
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length) => {
                const obj = {
                    type: MessageType.PUT_VALUE,
                    closer: [],
                    providers: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.type = MessageType.codec().decode(reader);
                            break;
                        }
                        case 10: {
                            obj.clusterLevel = reader.int32();
                            break;
                        }
                        case 2: {
                            obj.key = reader.bytes();
                            break;
                        }
                        case 3: {
                            obj.record = reader.bytes();
                            break;
                        }
                        case 8: {
                            obj.closer.push(PeerInfo.codec().decode(reader, reader.uint32()));
                            break;
                        }
                        case 9: {
                            obj.providers.push(PeerInfo.codec().decode(reader, reader.uint32()));
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    Message.encode = (obj) => {
        return encodeMessage(obj, Message.codec());
    };
    Message.decode = (buf) => {
        return decodeMessage(buf, Message.codec());
    };
})(Message || (Message = {}));
//# sourceMappingURL=dht.js.map