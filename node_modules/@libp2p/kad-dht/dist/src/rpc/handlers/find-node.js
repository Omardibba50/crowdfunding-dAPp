import { CodeError } from '@libp2p/interface';
import { protocols } from '@multiformats/multiaddr';
import { equals as uint8ArrayEquals } from 'uint8arrays';
import { MessageType } from '../../message/dht.js';
export class FindNodeHandler {
    peerRouting;
    peerInfoMapper;
    peerId;
    addressManager;
    log;
    constructor(components, init) {
        const { peerRouting, logPrefix } = init;
        this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);
        this.peerId = components.peerId;
        this.addressManager = components.addressManager;
        this.peerRouting = peerRouting;
        this.peerInfoMapper = init.peerInfoMapper;
    }
    /**
     * Process `FindNode` DHT messages
     */
    async handle(peerId, msg) {
        this.log('incoming request from %p for peers closer to %b', peerId, msg.key);
        if (msg.key == null) {
            throw new CodeError('Invalid FIND_NODE message received - key was missing', 'ERR_INVALID_MESSAGE');
        }
        const closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);
        if (uint8ArrayEquals(this.peerId.toBytes(), msg.key)) {
            closer.push({
                id: this.peerId,
                multiaddrs: this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))
            });
        }
        const response = {
            type: MessageType.FIND_NODE,
            clusterLevel: msg.clusterLevel,
            closer: closer
                .map(this.peerInfoMapper)
                .filter(({ multiaddrs }) => multiaddrs.length)
                .map(peerInfo => ({
                id: peerInfo.id.toBytes(),
                multiaddrs: peerInfo.multiaddrs.map(ma => ma.bytes)
            })),
            providers: []
        };
        if (response.closer.length === 0) {
            this.log('could not find any peers closer to %b than %p', msg.key, peerId);
        }
        return response;
    }
}
//# sourceMappingURL=find-node.js.map