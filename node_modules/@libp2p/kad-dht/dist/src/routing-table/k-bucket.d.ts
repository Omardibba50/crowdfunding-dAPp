import { TypedEventEmitter } from '@libp2p/interface';
import type { PeerId } from '@libp2p/interface';
export interface PingEventDetails {
    oldContacts: Peer[];
    newContact: Peer;
}
export interface KBucketEvents {
    'ping': CustomEvent<PingEventDetails>;
    'added': CustomEvent<Peer>;
    'removed': CustomEvent<Peer>;
}
export interface KBucketOptions {
    /**
     * The current peer. All subsequently added peers must have a KadID that is
     * the same length as this peer.
     */
    localPeer: Peer;
    /**
     * How many bits of the key to use when forming the bucket trie. The larger
     * this value, the deeper the tree will grow and the slower the lookups will
     * be but the peers returned will be more specific to the key.
     */
    prefixLength: number;
    /**
     * The number of nodes that a max-depth k-bucket can contain before being
     * full.
     *
     * @default 20
     */
    kBucketSize?: number;
    /**
     * The number of nodes that an intermediate k-bucket can contain before being
     * split.
     *
     * @default kBucketSize
     */
    splitThreshold?: number;
    /**
     * The number of nodes to ping when a bucket that should not be split becomes
     * full. KBucket will emit a `ping` event that contains `numberOfNodesToPing`
     * nodes that have not been contacted the longest.
     */
    numberOfNodesToPing?: number;
}
export interface Peer {
    kadId: Uint8Array;
    peerId: PeerId;
}
export interface LeafBucket {
    prefix: string;
    depth: number;
    peers: Peer[];
}
export interface InternalBucket {
    prefix: string;
    depth: number;
    left: Bucket;
    right: Bucket;
}
export type Bucket = LeafBucket | InternalBucket;
export declare function isLeafBucket(obj: any): obj is LeafBucket;
/**
 * Implementation of a Kademlia DHT routing table as a prefix binary trie with
 * configurable prefix length, bucket split threshold and size.
 */
export declare class KBucket extends TypedEventEmitter<KBucketEvents> {
    root: Bucket;
    localPeer: Peer;
    private readonly prefixLength;
    private readonly splitThreshold;
    private readonly kBucketSize;
    private readonly numberOfNodesToPing;
    constructor(options: KBucketOptions);
    /**
     * Adds a contact to the k-bucket.
     *
     * @param {Peer} peer - the contact object to add
     */
    add(peer: Peer): void;
    /**
     * Get 0-n closest contacts to the provided node id. "Closest" here means:
     * closest according to the XOR metric of the contact node id.
     *
     * @param {Uint8Array} id - Contact node id
     * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
     */
    closest(id: Uint8Array, n?: number): Generator<PeerId, void, undefined>;
    /**
     * Counts the total number of contacts in the tree.
     *
     * @returns {number} The number of contacts held in the tree
     */
    count(): number;
    /**
     * Get a contact by its exact ID.
     * If this is a leaf, loop through the bucket contents and return the correct
     * contact if we have it or null if not. If this is an inner node, determine
     * which branch of the tree to traverse and repeat.
     *
     * @param {Uint8Array} kadId - The ID of the contact to fetch.
     * @returns {object | undefined} The contact if available, otherwise null
     */
    get(kadId: Uint8Array): Peer | undefined;
    /**
     * Removes contact with the provided id.
     *
     * @param {Uint8Array} kadId - The ID of the contact to remove
     */
    remove(kadId: Uint8Array): void;
    /**
     * Similar to `toArray()` but instead of buffering everything up into an
     * array before returning it, yields contacts as they are encountered while
     * walking the tree.
     *
     * @returns {Iterable} All of the contacts in the tree, as an iterable
     */
    toIterable(): Generator<Peer, void, undefined>;
    /**
     * Default distance function. Finds the XOR distance between firstId and
     * secondId.
     *
     * @param  {Uint8Array} firstId - Uint8Array containing first id.
     * @param  {Uint8Array} secondId - Uint8Array containing second id.
     * @returns {number} Integer The XOR distance between firstId and secondId.
     */
    distance(firstId: Uint8Array, secondId: Uint8Array): bigint;
    /**
     * Determines whether the id at the bitIndex is 0 or 1
     * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
     *
     * @param {Uint8Array} kadId - Id to compare localNodeId with
     * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
     */
    private _determineBucket;
    /**
     * Returns the index of the contact with provided
     * id if it exists, returns -1 otherwise.
     *
     * @param {object} bucket - internal object that has 2 leafs: left and right
     * @param {Uint8Array} kadId - KadId of peer
     * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
     */
    private _indexOf;
    /**
     * Modify the bucket, turn it from a leaf bucket to an internal bucket
     *
     * @param {any} bucket - bucket for splitting
     */
    private _split;
}
//# sourceMappingURL=k-bucket.d.ts.map