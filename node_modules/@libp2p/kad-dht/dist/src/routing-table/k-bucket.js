import { TypedEventEmitter } from '@libp2p/interface';
import map from 'it-map';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import { xor as uint8ArrayXor } from 'uint8arrays/xor';
import { PeerDistanceList } from '../peer-list/peer-distance-list.js';
import { KBUCKET_SIZE } from './index.js';
function arrayEquals(array1, array2) {
    if (array1 === array2) {
        return true;
    }
    if (array1.length !== array2.length) {
        return false;
    }
    for (let i = 0, length = array1.length; i < length; ++i) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
function ensureInt8(name, val) {
    if (!(val instanceof Uint8Array)) {
        throw new TypeError(name + ' is not a Uint8Array');
    }
    if (val.byteLength !== 32) {
        throw new TypeError(name + ' had incorrect length');
    }
}
export function isLeafBucket(obj) {
    return Array.isArray(obj?.peers);
}
/**
 * Implementation of a Kademlia DHT routing table as a prefix binary trie with
 * configurable prefix length, bucket split threshold and size.
 */
export class KBucket extends TypedEventEmitter {
    root;
    localPeer;
    prefixLength;
    splitThreshold;
    kBucketSize;
    numberOfNodesToPing;
    constructor(options) {
        super();
        this.localPeer = options.localPeer;
        this.prefixLength = options.prefixLength;
        this.kBucketSize = options.kBucketSize ?? KBUCKET_SIZE;
        this.splitThreshold = options.splitThreshold ?? this.kBucketSize;
        this.numberOfNodesToPing = options.numberOfNodesToPing ?? 3;
        ensureInt8('options.localPeer.kadId', options.localPeer.kadId);
        this.root = {
            prefix: '',
            depth: 0,
            peers: []
        };
    }
    /**
     * Adds a contact to the k-bucket.
     *
     * @param {Peer} peer - the contact object to add
     */
    add(peer) {
        ensureInt8('peer.kadId', peer?.kadId);
        const bucket = this._determineBucket(peer.kadId);
        // check if the contact already exists
        if (this._indexOf(bucket, peer.kadId) > -1) {
            return;
        }
        // are there too many peers in the bucket and can we make the trie deeper?
        if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {
            // split the bucket
            this._split(bucket);
            // try again
            this.add(peer);
            return;
        }
        // is there space in the bucket?
        if (bucket.peers.length < this.kBucketSize) {
            bucket.peers.push(peer);
            this.safeDispatchEvent('added', { detail: peer });
            return;
        }
        // we are at the bottom of the trie and the bucket is full so we can't add
        // any more peers.
        //
        // instead ping the first this.numberOfNodesToPing in order to determine
        // if they are still online.
        //
        // only add the new peer if one of the pinged nodes does not respond, this
        // prevents DoS flooding with new invalid contacts.
        this.safeDispatchEvent('ping', {
            detail: {
                oldContacts: bucket.peers.slice(0, this.numberOfNodesToPing),
                newContact: peer
            }
        });
    }
    /**
     * Get 0-n closest contacts to the provided node id. "Closest" here means:
     * closest according to the XOR metric of the contact node id.
     *
     * @param {Uint8Array} id - Contact node id
     * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
     */
    *closest(id, n = this.kBucketSize) {
        const list = new PeerDistanceList(id, n);
        for (const peer of this.toIterable()) {
            list.addWitKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);
        }
        yield* map(list.peers, info => info.id);
    }
    /**
     * Counts the total number of contacts in the tree.
     *
     * @returns {number} The number of contacts held in the tree
     */
    count() {
        function countBucket(bucket) {
            if (isLeafBucket(bucket)) {
                return bucket.peers.length;
            }
            let count = 0;
            if (bucket.left != null) {
                count += countBucket(bucket.left);
            }
            if (bucket.right != null) {
                count += countBucket(bucket.right);
            }
            return count;
        }
        return countBucket(this.root);
    }
    /**
     * Get a contact by its exact ID.
     * If this is a leaf, loop through the bucket contents and return the correct
     * contact if we have it or null if not. If this is an inner node, determine
     * which branch of the tree to traverse and repeat.
     *
     * @param {Uint8Array} kadId - The ID of the contact to fetch.
     * @returns {object | undefined} The contact if available, otherwise null
     */
    get(kadId) {
        const bucket = this._determineBucket(kadId);
        const index = this._indexOf(bucket, kadId);
        return bucket.peers[index];
    }
    /**
     * Removes contact with the provided id.
     *
     * @param {Uint8Array} kadId - The ID of the contact to remove
     */
    remove(kadId) {
        const bucket = this._determineBucket(kadId);
        const index = this._indexOf(bucket, kadId);
        if (index > -1) {
            const peer = bucket.peers.splice(index, 1)[0];
            this.safeDispatchEvent('removed', {
                detail: peer
            });
        }
    }
    /**
     * Similar to `toArray()` but instead of buffering everything up into an
     * array before returning it, yields contacts as they are encountered while
     * walking the tree.
     *
     * @returns {Iterable} All of the contacts in the tree, as an iterable
     */
    *toIterable() {
        function* iterate(bucket) {
            if (isLeafBucket(bucket)) {
                yield* bucket.peers;
                return;
            }
            yield* iterate(bucket.left);
            yield* iterate(bucket.right);
        }
        yield* iterate(this.root);
    }
    /**
     * Default distance function. Finds the XOR distance between firstId and
     * secondId.
     *
     * @param  {Uint8Array} firstId - Uint8Array containing first id.
     * @param  {Uint8Array} secondId - Uint8Array containing second id.
     * @returns {number} Integer The XOR distance between firstId and secondId.
     */
    distance(firstId, secondId) {
        return BigInt('0x' + uint8ArrayToString(uint8ArrayXor(firstId, secondId), 'base16'));
    }
    /**
     * Determines whether the id at the bitIndex is 0 or 1
     * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
     *
     * @param {Uint8Array} kadId - Id to compare localNodeId with
     * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
     */
    _determineBucket(kadId) {
        const bitString = uint8ArrayToString(kadId, 'base2');
        const prefix = bitString.substring(0, this.prefixLength);
        function findBucket(bucket, bitIndex = 0) {
            if (isLeafBucket(bucket)) {
                return bucket;
            }
            const bit = prefix[bitIndex];
            if (bit === '0') {
                return findBucket(bucket.left, bitIndex + 1);
            }
            return findBucket(bucket.right, bitIndex + 1);
        }
        return findBucket(this.root);
    }
    /**
     * Returns the index of the contact with provided
     * id if it exists, returns -1 otherwise.
     *
     * @param {object} bucket - internal object that has 2 leafs: left and right
     * @param {Uint8Array} kadId - KadId of peer
     * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
     */
    _indexOf(bucket, kadId) {
        return bucket.peers.findIndex(peer => arrayEquals(peer.kadId, kadId));
    }
    /**
     * Modify the bucket, turn it from a leaf bucket to an internal bucket
     *
     * @param {any} bucket - bucket for splitting
     */
    _split(bucket) {
        const depth = bucket.depth + 1;
        // create child buckets
        const left = {
            prefix: '0',
            depth,
            peers: []
        };
        const right = {
            prefix: '1',
            depth,
            peers: []
        };
        // redistribute peers
        for (const peer of bucket.peers) {
            const bitString = uint8ArrayToString(peer.kadId, 'base2');
            if (bitString[depth] === '0') {
                left.peers.push(peer);
            }
            else {
                right.peers.push(peer);
            }
        }
        // convert leaf bucket to internal bucket
        // @ts-expect-error peers is not a property of LeafBucket
        delete bucket.peers;
        // @ts-expect-error left is not a property of LeafBucket
        bucket.left = left;
        // @ts-expect-error right is not a property of LeafBucket
        bucket.right = right;
    }
}
//# sourceMappingURL=k-bucket.js.map