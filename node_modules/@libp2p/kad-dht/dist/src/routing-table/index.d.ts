import { TypedEventEmitter } from '@libp2p/interface';
import { PeerQueue } from '@libp2p/utils/peer-queue';
import { KBucket, type PingEventDetails } from './k-bucket.js';
import type { ComponentLogger, Metrics, PeerId, PeerStore, Startable } from '@libp2p/interface';
import type { ConnectionManager } from '@libp2p/interface-internal';
export declare const KAD_CLOSE_TAG_NAME = "kad-close";
export declare const KAD_CLOSE_TAG_VALUE = 50;
export declare const KBUCKET_SIZE = 20;
export declare const PREFIX_LENGTH = 32;
export declare const PING_TIMEOUT = 10000;
export declare const PING_CONCURRENCY = 10;
export interface RoutingTableInit {
    logPrefix: string;
    protocol: string;
    prefixLength?: number;
    splitThreshold?: number;
    kBucketSize?: number;
    pingTimeout?: number;
    pingConcurrency?: number;
    tagName?: string;
    tagValue?: number;
}
export interface RoutingTableComponents {
    peerId: PeerId;
    peerStore: PeerStore;
    connectionManager: ConnectionManager;
    metrics?: Metrics;
    logger: ComponentLogger;
}
export interface RoutingTableEvents {
    'peer:add': CustomEvent<PeerId>;
    'peer:remove': CustomEvent<PeerId>;
}
/**
 * A wrapper around `k-bucket`, to provide easy store and
 * retrieval for peers.
 */
export declare class RoutingTable extends TypedEventEmitter<RoutingTableEvents> implements Startable {
    kBucketSize: number;
    kb?: KBucket;
    pingQueue: PeerQueue<boolean>;
    private readonly log;
    private readonly components;
    private readonly prefixLength;
    private readonly splitThreshold;
    private readonly pingTimeout;
    private readonly pingConcurrency;
    private running;
    private readonly protocol;
    private readonly tagName;
    private readonly tagValue;
    private readonly metrics?;
    constructor(components: RoutingTableComponents, init: RoutingTableInit);
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Keep track of our k-closest peers and tag them in the peer store as such
     * - this will lower the chances that connections to them get closed when
     * we reach connection limits
     */
    _tagPeers(kBuck: KBucket): void;
    /**
     * Called on the `ping` event from `k-bucket` when a bucket is full
     * and cannot split.
     *
     * `oldContacts.length` is defined by the `numberOfNodesToPing` param
     * passed to the `k-bucket` constructor.
     *
     * `oldContacts` will not be empty and is the list of contacts that
     * have not been contacted for the longest.
     */
    _onPing(evt: CustomEvent<PingEventDetails>): Promise<void>;
    /**
     * Amount of currently stored peers
     */
    get size(): number;
    /**
     * Find a specific peer by id
     */
    find(peer: PeerId): Promise<PeerId | undefined>;
    /**
     * Retrieve the closest peers to the given kadId
     */
    closestPeer(kadId: Uint8Array): PeerId | undefined;
    /**
     * Retrieve the `count`-closest peers to the given kadId
     */
    closestPeers(kadId: Uint8Array, count?: number): PeerId[];
    /**
     * Add or update the routing table with the given peer
     */
    add(peerId: PeerId): Promise<void>;
    /**
     * Remove a given peer from the table
     */
    remove(peer: PeerId): Promise<void>;
    private updateMetrics;
}
//# sourceMappingURL=index.d.ts.map