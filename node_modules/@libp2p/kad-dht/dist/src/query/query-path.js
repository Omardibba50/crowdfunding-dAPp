import { CodeError, setMaxListeners } from '@libp2p/interface';
import { Queue } from '@libp2p/utils/queue';
import { anySignal } from 'any-signal';
import { xor as uint8ArrayXor } from 'uint8arrays/xor';
import { xorCompare as uint8ArrayXorCompare } from 'uint8arrays/xor-compare';
import { convertPeerId, convertBuffer } from '../utils.js';
import { queryErrorEvent } from './events.js';
/**
 * Walks a path through the DHT, calling the passed query function for
 * every peer encountered that we have not seen before
 */
export async function* queryPath(options) {
    const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, queryFuncTimeout, log, peersSeen, connectionManager } = options;
    // Only ALPHA node/value lookups are allowed at any given time for each process
    // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1
    const queue = new Queue({
        concurrency: alpha,
        sort: (a, b) => uint8ArrayXorCompare(a.options.distance, b.options.distance)
    });
    // perform lookups on kadId, not the actual value
    const kadId = await convertBuffer(key);
    /**
     * Adds the passed peer to the query queue if it's not us and no
     * other path has passed through this peer
     */
    function queryPeer(peer, peerKadId) {
        if (peer == null) {
            return;
        }
        peersSeen.add(peer);
        const peerXor = uint8ArrayXor(peerKadId, kadId);
        queue.add(async () => {
            const signals = [signal];
            if (queryFuncTimeout != null) {
                signals.push(AbortSignal.timeout(queryFuncTimeout));
            }
            const compoundSignal = anySignal(signals);
            // this signal can get listened to a lot
            setMaxListeners(Infinity, compoundSignal);
            try {
                for await (const event of query({
                    key,
                    peer,
                    signal: compoundSignal,
                    pathIndex,
                    numPaths
                })) {
                    if (compoundSignal.aborted) {
                        return;
                    }
                    // if there are closer peers and the query has not completed, continue the query
                    if (event.name === 'PEER_RESPONSE') {
                        for (const closerPeer of event.closer) {
                            if (peersSeen.has(closerPeer.id)) { // eslint-disable-line max-depth
                                log('already seen %p in query', closerPeer.id);
                                continue;
                            }
                            if (ourPeerId.equals(closerPeer.id)) { // eslint-disable-line max-depth
                                log('not querying ourselves');
                                continue;
                            }
                            if (!(await connectionManager.isDialable(closerPeer.multiaddrs))) { // eslint-disable-line max-depth
                                log('not querying undialable peer');
                                continue;
                            }
                            const closerPeerKadId = await convertPeerId(closerPeer.id);
                            const closerPeerXor = uint8ArrayXor(closerPeerKadId, kadId);
                            // only continue query if closer peer is actually closer
                            if (uint8ArrayXorCompare(closerPeerXor, peerXor) !== -1) { // eslint-disable-line max-depth
                                log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer);
                                continue;
                            }
                            log('querying closer peer %p', closerPeer.id);
                            queryPeer(closerPeer.id, closerPeerKadId);
                        }
                    }
                    queue.safeDispatchEvent('completed', {
                        detail: event
                    });
                }
            }
            catch (err) {
                if (!signal.aborted) {
                    return queryErrorEvent({
                        from: peer,
                        error: err
                    }, options);
                }
            }
            finally {
                compoundSignal.clear();
            }
        }, {
            distance: peerXor
        }).catch(err => {
            log.error(err);
        });
    }
    // begin the query with the starting peer
    queryPeer(startingPeer, await convertPeerId(startingPeer));
    try {
        // yield results as they come in
        for await (const event of queue.toGenerator({ signal })) {
            if (event != null) {
                yield event;
            }
        }
    }
    catch (err) {
        if (signal.aborted) {
            throw new CodeError('Query aborted', 'ERR_QUERY_ABORTED');
        }
        throw err;
    }
}
//# sourceMappingURL=query-path.js.map