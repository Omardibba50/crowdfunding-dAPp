import type { KadDHTComponents, DHTRecord, FinalPeerEvent, QueryEvent, Validators } from '../index.js';
import type { Network } from '../network.js';
import type { QueryManager, QueryOptions } from '../query/manager.js';
import type { RoutingTable } from '../routing-table/index.js';
import type { PeerId, PeerInfo, RoutingOptions } from '@libp2p/interface';
export interface PeerRoutingInit {
    routingTable: RoutingTable;
    network: Network;
    validators: Validators;
    queryManager: QueryManager;
    logPrefix: string;
}
export declare class PeerRouting {
    private readonly log;
    private readonly routingTable;
    private readonly network;
    private readonly validators;
    private readonly queryManager;
    private readonly peerStore;
    private readonly peerId;
    constructor(components: KadDHTComponents, init: PeerRoutingInit);
    /**
     * Look if we are connected to a peer with the given id.
     * Returns its id and addresses, if found, otherwise `undefined`.
     */
    findPeerLocal(peer: PeerId): Promise<PeerInfo | undefined>;
    /**
     * Get a value via rpc call for the given parameters
     */
    _getValueSingle(peer: PeerId, key: Uint8Array, options?: RoutingOptions): AsyncGenerator<QueryEvent>;
    /**
     * Get the public key directly from a node
     */
    getPublicKeyFromNode(peer: PeerId, options?: RoutingOptions): AsyncGenerator<QueryEvent>;
    /**
     * Search for a peer with the given ID
     */
    findPeer(id: PeerId, options?: RoutingOptions): AsyncGenerator<FinalPeerEvent | QueryEvent>;
    /**
     * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from
     * a multihash or a peer ID
     */
    getClosestPeers(key: Uint8Array, options?: QueryOptions): AsyncGenerator<QueryEvent>;
    /**
     * Query a particular peer for the value for the given key.
     * It will either return the value or a list of closer peers.
     *
     * Note: The peerStore is updated with new addresses found for the given peer.
     */
    getValueOrPeers(peer: PeerId, key: Uint8Array, options?: RoutingOptions): AsyncGenerator<QueryEvent>;
    /**
     * Verify a record, fetching missing public keys from the network.
     * Throws an error if the record is invalid.
     */
    _verifyRecordOnline(record: DHTRecord): Promise<void>;
    /**
     * Get the nearest peers to the given query, but if closer
     * than self
     */
    getCloserPeersOffline(key: Uint8Array, closerThan: PeerId): Promise<PeerInfo[]>;
}
//# sourceMappingURL=index.d.ts.map