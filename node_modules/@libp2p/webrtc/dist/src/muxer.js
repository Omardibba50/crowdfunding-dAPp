import { createStream } from './stream.js';
import { drainAndClose, nopSink, nopSource } from './util.js';
const PROTOCOL = '/webrtc';
export class DataChannelMuxerFactory {
    protocol;
    /**
     * WebRTC Peer Connection
     */
    peerConnection;
    bufferedStreams = [];
    metrics;
    dataChannelOptions;
    components;
    log;
    constructor(components, init) {
        this.components = components;
        this.peerConnection = init.peerConnection;
        this.metrics = init.metrics;
        this.protocol = init.protocol ?? PROTOCOL;
        this.dataChannelOptions = init.dataChannelOptions ?? {};
        this.log = components.logger.forComponent('libp2p:webrtc:datachannelmuxerfactory');
        // store any datachannels opened before upgrade has been completed
        this.peerConnection.ondatachannel = ({ channel }) => {
            this.log.trace('incoming early datachannel with channel id %d and label "%s"', channel.id);
            // 'init' channel is only used during connection establishment
            if (channel.label === 'init') {
                this.log.trace('closing early init channel');
                channel.close();
                return;
            }
            // @ts-expect-error fields are set below
            const bufferedStream = {};
            const stream = createStream({
                channel,
                direction: 'inbound',
                onEnd: (err) => {
                    bufferedStream.onEnd(err);
                },
                logger: components.logger,
                ...this.dataChannelOptions
            });
            bufferedStream.stream = stream;
            bufferedStream.channel = channel;
            bufferedStream.onEnd = () => {
                this.bufferedStreams = this.bufferedStreams.filter(s => s.stream.id !== stream.id);
            };
            this.bufferedStreams.push(bufferedStream);
        };
    }
    createStreamMuxer(init) {
        return new DataChannelMuxer(this.components, {
            ...init,
            peerConnection: this.peerConnection,
            dataChannelOptions: this.dataChannelOptions,
            metrics: this.metrics,
            streams: this.bufferedStreams,
            protocol: this.protocol
        });
    }
}
/**
 * A libp2p data channel stream muxer
 */
export class DataChannelMuxer {
    init;
    /**
     * Array of streams in the data channel
     */
    streams;
    protocol;
    log;
    peerConnection;
    dataChannelOptions;
    metrics;
    logger;
    constructor(components, init) {
        this.init = init;
        this.log = components.logger.forComponent('libp2p:webrtc:muxer');
        this.logger = components.logger;
        this.streams = init.streams.map(s => s.stream);
        this.peerConnection = init.peerConnection;
        this.protocol = init.protocol ?? PROTOCOL;
        this.metrics = init.metrics;
        this.dataChannelOptions = init.dataChannelOptions ?? {};
        /**
         * Fired when a data channel has been added to the connection has been
         * added by the remote peer.
         *
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/datachannel_event}
         */
        this.peerConnection.ondatachannel = ({ channel }) => {
            this.log.trace('incoming datachannel with channel id %d', channel.id);
            // 'init' channel is only used during connection establishment
            if (channel.label === 'init') {
                this.log.trace('closing init channel');
                channel.close();
                return;
            }
            const stream = createStream({
                channel,
                direction: 'inbound',
                onEnd: () => {
                    this.log('incoming channel %s ended with state %s', channel.id, channel.readyState);
                    this.#onStreamEnd(stream, channel);
                },
                logger: this.logger,
                ...this.dataChannelOptions
            });
            this.streams.push(stream);
            this.metrics?.increment({ incoming_stream: true });
            init?.onIncomingStream?.(stream);
        };
        // the DataChannelMuxer constructor is called during set up of the
        // connection by the upgrader.
        //
        // If we invoke `init.onIncomingStream` immediately, the connection object
        // will not be set up yet so add a tiny delay before letting the
        // connection know about early streams
        if (this.init.streams.length > 0) {
            queueMicrotask(() => {
                this.init.streams.forEach(bufferedStream => {
                    bufferedStream.onEnd = () => {
                        this.log('incoming early channel %s ended with state %s', bufferedStream.channel.id, bufferedStream.channel.readyState);
                        this.#onStreamEnd(bufferedStream.stream, bufferedStream.channel);
                    };
                    this.metrics?.increment({ incoming_stream: true });
                    this.init?.onIncomingStream?.(bufferedStream.stream);
                });
            });
        }
    }
    #onStreamEnd(stream, channel) {
        this.log.trace('stream %s %s %s onEnd', stream.direction, stream.id, stream.protocol);
        drainAndClose(channel, `${stream.direction} ${stream.id} ${stream.protocol}`, this.dataChannelOptions.drainTimeout, {
            log: this.log
        });
        this.streams = this.streams.filter(s => s.id !== stream.id);
        this.metrics?.increment({ stream_end: true });
        this.init?.onStreamEnd?.(stream);
    }
    /**
     * Gracefully close all tracked streams and stop the muxer
     */
    async close(options) {
        try {
            await Promise.all(this.streams.map(async (stream) => stream.close(options)));
        }
        catch (err) {
            this.abort(err);
        }
    }
    /**
     * Abort all tracked streams and stop the muxer
     */
    abort(err) {
        for (const stream of this.streams) {
            stream.abort(err);
        }
    }
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    source = nopSource();
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    sink = nopSink;
    newStream() {
        // The spec says the label SHOULD be an empty string: https://github.com/libp2p/specs/blob/master/webrtc/README.md#rtcdatachannel-label
        const channel = this.peerConnection.createDataChannel('');
        this.log.trace('opened outgoing datachannel with channel id %s', channel.id);
        const stream = createStream({
            channel,
            direction: 'outbound',
            onEnd: () => {
                this.log('outgoing channel %s ended with state %s', channel.id, channel.readyState);
                this.#onStreamEnd(stream, channel);
            },
            logger: this.logger,
            ...this.dataChannelOptions
        });
        this.streams.push(stream);
        this.metrics?.increment({ outgoing_stream: true });
        return stream;
    }
}
//# sourceMappingURL=muxer.js.map