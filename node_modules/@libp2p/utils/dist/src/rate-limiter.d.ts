export interface RateLimiterInit {
    /**
     * Number of points
     *
     * @default 4
     */
    points?: number;
    /**
     * Per seconds
     *
     * @default 1
     */
    duration?: number;
    /**
     * Block if consumed more than points in current duration for blockDuration seconds
     *
     * @default 0
     */
    blockDuration?: number;
    /**
     * Execute allowed actions evenly over duration
     *
     * @default false
     */
    execEvenly?: boolean;
    /**
     * ms, works with execEvenly=true option
     *
     * @default duration * 1000 / points
     */
    execEvenlyMinDelayMs?: number;
    /**
     * @default rlflx
     */
    keyPrefix?: string;
}
export interface GetKeySecDurationOptions {
    customDuration?: number;
}
export interface RateLimiterResult {
    remainingPoints: number;
    msBeforeNext: number;
    consumedPoints: number;
    isFirstInDuration: boolean;
}
export interface RateRecord {
    value: number;
    expiresAt?: Date;
    timeoutId?: ReturnType<typeof setTimeout>;
}
export declare class RateLimiter {
    readonly memoryStorage: MemoryStorage;
    protected points: number;
    protected duration: number;
    protected blockDuration: number;
    protected execEvenly: boolean;
    protected execEvenlyMinDelayMs: number;
    protected keyPrefix: string;
    constructor(opts?: RateLimiterInit);
    consume(key: string, pointsToConsume?: number, options?: GetKeySecDurationOptions): Promise<RateLimiterResult>;
    penalty(key: string, points?: number, options?: GetKeySecDurationOptions): RateLimiterResult;
    reward(key: string, points?: number, options?: GetKeySecDurationOptions): RateLimiterResult;
    /**
     * Block any key for secDuration seconds
     *
     * @param key
     * @param secDuration
     */
    block(key: string, secDuration: number): RateLimiterResult;
    set(key: string, points: number, secDuration?: number): RateLimiterResult;
    get(key: string): RateLimiterResult | undefined;
    delete(key: string): void;
    private _getKeySecDuration;
    getKey(key: string): string;
    parseKey(rlKey: string): string;
}
declare class MemoryStorage {
    readonly storage: Map<string, RateRecord>;
    constructor();
    incrby(key: string, value: number, durationSec: number): RateLimiterResult;
    set(key: string, value: number, durationSec: number): RateLimiterResult;
    get(key: string): RateLimiterResult | undefined;
    delete(key: string): boolean;
}
export {};
//# sourceMappingURL=rate-limiter.d.ts.map