import { serviceDependencies } from '@libp2p/interface';
import { type Multiaddr } from '@multiformats/multiaddr';
import type { DCUtRServiceComponents, DCUtRServiceInit } from './index.js';
import type { Connection, Stream, Startable } from '@libp2p/interface';
export declare class DefaultDCUtRService implements Startable {
    private started;
    private readonly timeout;
    private readonly retries;
    private readonly maxInboundStreams;
    private readonly maxOutboundStreams;
    private readonly peerStore;
    private readonly registrar;
    private readonly connectionManager;
    private readonly addressManager;
    private readonly transportManager;
    private topologyId?;
    private readonly log;
    constructor(components: DCUtRServiceComponents, init: DCUtRServiceInit);
    readonly [Symbol.toStringTag] = "@libp2p/dcutr";
    readonly [serviceDependencies]: string[];
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Perform the inbound connection upgrade as B
     *
     * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
     */
    upgradeInbound(relayedConnection: Connection): Promise<void>;
    /**
     * This is performed when A has dialed B via a relay but A also has a public
     * address that B can dial directly
     */
    attemptUnilateralConnectionUpgrade(relayedConnection: Connection): Promise<boolean>;
    /**
     * Perform the connection upgrade as A
     *
     * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
     */
    handleIncomingUpgrade(stream: Stream, relayedConnection: Connection): Promise<void>;
    /**
     * Takes the `addr` and converts it to a Multiaddr if possible
     */
    getDialableMultiaddrs(addrs: Array<Uint8Array | string | null | undefined>): Multiaddr[];
}
//# sourceMappingURL=dcutr.d.ts.map