import { CustomEvent, TypedEventEmitter, peerDiscoverySymbol, serviceCapabilities } from '@libp2p/interface';
import multicastDNS from 'multicast-dns';
import * as query from './query.js';
import { stringGen } from './utils.js';
export class MulticastDNS extends TypedEventEmitter {
    mdns;
    log;
    broadcast;
    interval;
    serviceTag;
    peerName;
    port;
    ip;
    _queryInterval;
    components;
    constructor(components, init = {}) {
        super();
        this.log = components.logger.forComponent('libp2p:mdns');
        this.broadcast = init.broadcast !== false;
        this.interval = init.interval ?? (1e3 * 10);
        this.serviceTag = init.serviceTag ?? '_p2p._udp.local';
        this.ip = init.ip ?? '224.0.0.251';
        this.peerName = init.peerName ?? stringGen(63);
        // 63 is dns label limit
        if (this.peerName.length >= 64) {
            throw new Error('Peer name should be less than 64 chars long');
        }
        this.port = init.port ?? 5353;
        this.components = components;
        this._queryInterval = null;
        this._onMdnsQuery = this._onMdnsQuery.bind(this);
        this._onMdnsResponse = this._onMdnsResponse.bind(this);
        this._onMdnsWarning = this._onMdnsWarning.bind(this);
        this._onMdnsError = this._onMdnsError.bind(this);
    }
    [peerDiscoverySymbol] = this;
    [Symbol.toStringTag] = '@libp2p/mdns';
    [serviceCapabilities] = [
        '@libp2p/peer-discovery'
    ];
    isStarted() {
        return Boolean(this.mdns);
    }
    /**
     * Start sending queries to the LAN.
     *
     * @returns {void}
     */
    async start() {
        if (this.mdns != null) {
            return;
        }
        this.mdns = multicastDNS({ port: this.port, ip: this.ip });
        this.mdns.on('query', this._onMdnsQuery);
        this.mdns.on('response', this._onMdnsResponse);
        this.mdns.on('warning', this._onMdnsWarning);
        this.mdns.on('error', this._onMdnsError);
        this._queryInterval = query.queryLAN(this.mdns, this.serviceTag, this.interval, {
            log: this.log
        });
    }
    _onMdnsQuery(event) {
        if (this.mdns == null) {
            return;
        }
        this.log.trace('received incoming mDNS query');
        query.gotQuery(event, this.mdns, this.peerName, this.components.addressManager.getAddresses(), this.serviceTag, this.broadcast, {
            log: this.log
        });
    }
    _onMdnsResponse(event) {
        this.log.trace('received mDNS query response');
        try {
            const foundPeer = query.gotResponse(event, this.peerName, this.serviceTag, {
                log: this.log
            });
            if (foundPeer != null) {
                this.log('discovered peer in mDNS query response %p', foundPeer.id);
                this.dispatchEvent(new CustomEvent('peer', {
                    detail: foundPeer
                }));
            }
        }
        catch (err) {
            this.log.error('Error processing peer response', err);
        }
    }
    _onMdnsWarning(err) {
        this.log.error('mdns warning', err);
    }
    _onMdnsError(err) {
        this.log.error('mdns error', err);
    }
    /**
     * Stop sending queries to the LAN.
     *
     * @returns {Promise}
     */
    async stop() {
        if (this.mdns == null) {
            return;
        }
        this.mdns.removeListener('query', this._onMdnsQuery);
        this.mdns.removeListener('response', this._onMdnsResponse);
        this.mdns.removeListener('warning', this._onMdnsWarning);
        this.mdns.removeListener('error', this._onMdnsError);
        if (this._queryInterval != null) {
            clearInterval(this._queryInterval);
            this._queryInterval = null;
        }
        await new Promise((resolve) => {
            if (this.mdns != null) {
                this.mdns.destroy(resolve);
            }
            else {
                resolve();
            }
        });
        this.mdns = undefined;
    }
}
//# sourceMappingURL=mdns.js.map