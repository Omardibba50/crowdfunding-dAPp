(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PPing = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PPing=(()=>{var T=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var $=Object.getOwnPropertyNames;var q=Object.prototype.hasOwnProperty;var H=(n,t)=>{for(var e in t)T(n,e,{get:t[e],enumerable:!0})},K=(n,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of $(t))!q.call(n,o)&&o!==e&&T(n,o,{get:()=>t[o],enumerable:!(r=W(t,o))||r.enumerable});return n};var Y=n=>K(T({},"__esModule",{value:!0}),n);var at={};H(at,{PING_PROTOCOL:()=>B,ping:()=>ct});var a=class extends Error{code;props;constructor(t,e,r){super(t),this.code=e,this.name=r?.name??"CodeError",this.props=r??{}}};var P="ERR_TIMEOUT";function M(n,t){if(n===t)return!0;if(n.byteLength!==t.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n[e]!==t[e])return!1;return!0}var x=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var yt=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;var xt={}.toString;function C(n=32){if(x&&typeof x.getRandomValues=="function")return x.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function g(n){if(isNaN(n)||n<=0)throw new a("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return C(n)}function J(n){return n[Symbol.asyncIterator]!=null}function Q(n){if(J(n))return(async()=>{for await(let t of n)return t})();for(let t of n)return t}var U=Q;function b(){let n={};return n.promise=new Promise((t,e)=>{n.resolve=t,n.reject=e}),n}var E=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},m=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new E(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new E(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var A=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function w(n={}){return Z(e=>{let r=e.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function Z(n,t){t=t??{};let e=t.onEnd,r=new m,o,i,u,l=b(),c=async()=>{try{return r.isEmpty()?u?{done:!0}:await new Promise((s,p)=>{i=y=>{i=null,r.push(y);try{s(n(r))}catch(d){p(d)}return o}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{l.resolve(),l=b()})}},f=s=>i!=null?i(s):(r.push(s),o),_=s=>(r=new m,i!=null?i({error:s}):(r.push({error:s}),o)),N=s=>{if(u)return o;if(t?.objectMode!==!0&&s?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return f({done:!1,value:s})},R=s=>u?o:(u=!0,s!=null?_(s):f({done:!0})),X=()=>(r=new m,R(),{done:!0}),j=s=>(R(s),{done:!0});if(o={[Symbol.asyncIterator](){return this},next:c,return:X,throw:j,push:N,end:R,get readableLength(){return r.size},onEmpty:async s=>{let p=s?.signal;if(p?.throwIfAborted(),r.isEmpty())return;let y,d;p!=null&&(y=new Promise((lt,F)=>{d=()=>{F(new A)},p.addEventListener("abort",d)}));try{await Promise.race([l.promise,y])}finally{d!=null&&p!=null&&p?.removeEventListener("abort",d)}}},e==null)return o;let h=o;return o={[Symbol.asyncIterator](){return this},next(){return h.next()},throw(s){return h.throw(s),e!=null&&(e(s),e=void 0),{done:!0}},return(){return h.return(),e!=null&&(e(),e=void 0),{done:!0}},push:N,end(s){return h.end(s),e!=null&&(e(s),e=void 0),o},get readableLength(){return h.readableLength},onEmpty:s=>h.onEmpty(s)},o}function tt(n){return n[Symbol.asyncIterator]!=null}function et(...n){let t=[];for(let e of n)tt(e)||t.push(e);return t.length===n.length?function*(){for(let e of t)yield*e}():async function*(){let e=w({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(n.map(async r=>{for await(let o of r)e.push(o)})),e.end()}catch(r){e.end(r)}}),yield*e}()}var v=et;function S(n,...t){if(n==null)throw new Error("Empty pipeline");if(I(n)){let r=n;n=()=>r.source}else if(k(n)||D(n)){let r=n;n=()=>r}let e=[n,...t];if(e.length>1&&I(e[e.length-1])&&(e[e.length-1]=e[e.length-1].sink),e.length>2)for(let r=1;r<e.length-1;r++)I(e[r])&&(e[r]=rt(e[r]));return nt(...e)}var nt=(...n)=>{let t;for(;n.length>0;)t=n.shift()(t);return t},D=n=>n?.[Symbol.asyncIterator]!=null,k=n=>n?.[Symbol.iterator]!=null,I=n=>n==null?!1:n.sink!=null&&n.source!=null,rt=n=>t=>{let e=n.sink(t);if(e?.then!=null){let r=w({objectMode:!0});e.then(()=>{r.end()},u=>{r.end(u)});let o,i=n.source;if(D(i))o=async function*(){yield*i,r.end()};else if(k(i))o=function*(){yield*i,r.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return v(r,o())}return n.source};var B="/ipfs/ping/1.0.0";var G="1.0.0",V="ping",z="ipfs";var L="ERR_WRONG_PING_ACK";var O=class{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnTransientConnection;log;constructor(t,e={}){this.components=t,this.log=t.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${e.protocolPrefix??z}/${V}/${G}`,this.timeout=e.timeout??1e4,this.maxInboundStreams=e.maxInboundStreams??2,this.maxOutboundStreams=e.maxOutboundStreams??1,this.runOnTransientConnection=e.runOnTransientConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnTransientConnection:this.runOnTransientConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(t){this.log("incoming ping from %p",t.connection.remotePeer);let{stream:e}=t,r=Date.now();S(e,e).catch(o=>{this.log.error("incoming ping from %p failed with error",t.connection.remotePeer,o)}).finally(()=>{let o=Date.now()-r;this.log("incoming ping from %p complete in %dms",t.connection.remotePeer,o)})}async ping(t,e={}){this.log("pinging %p",t);let r=Date.now(),o=g(32),i=await this.components.connectionManager.openConnection(t,e),u,l=()=>{};if(e.signal==null){let c=AbortSignal.timeout(this.timeout);e={...e,signal:c}}try{u=await i.newStream(this.protocol,{...e,runOnTransientConnection:this.runOnTransientConnection}),l=()=>{u?.abort(new a("ping timeout",P))},e.signal?.addEventListener("abort",l,{once:!0});let c=await S([o],u,async _=>U(_)),f=Date.now()-r;if(c==null)throw new a(`Did not receive a ping ack after ${f}ms`,L);if(!M(o,c.subarray()))throw new a(`Received wrong ping ack after ${f}ms`,L);return this.log("ping %p complete in %dms",i.remotePeer,f),f}catch(c){throw this.log.error("error while pinging %p",i.remotePeer,c),u?.abort(c),c}finally{e.signal?.removeEventListener("abort",l),u!=null&&await u.close()}}};function ct(n={}){return t=>new O(t,n)}return Y(at);})();
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
return Libp2PPing}));
