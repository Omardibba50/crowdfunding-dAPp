import { webtransportBiDiStreamToStream } from './stream.js';
import { inertDuplex } from './utils/inert-duplex.js';
export function webtransportMuxer(wt, reader, logger, config) {
    let streamIDCounter = 0;
    const log = logger.forComponent('libp2p:webtransport:muxer');
    return {
        protocol: 'webtransport',
        createStreamMuxer: (init) => {
            // !TODO handle abort signal when WebTransport supports this.
            if (typeof init === 'function') {
                // The api docs say that init may be a function
                init = { onIncomingStream: init };
            }
            const activeStreams = [];
            Promise.resolve()
                .then(async () => {
                //! TODO unclear how to add backpressure here?
                while (true) {
                    const { done, value: wtStream } = await reader.read();
                    if (done) {
                        break;
                    }
                    if (activeStreams.length >= config.maxInboundStreams) {
                        log(`too many inbound streams open - ${activeStreams.length}/${config.maxInboundStreams}, closing new incoming stream`);
                        // We've reached our limit, close this stream.
                        wtStream.writable.close().catch((err) => {
                            log.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
                        });
                        wtStream.readable.cancel().catch((err) => {
                            log.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
                        });
                    }
                    else {
                        const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), 'inbound', activeStreams, init?.onStreamEnd, logger);
                        activeStreams.push(stream);
                        init?.onIncomingStream?.(stream);
                    }
                }
            })
                .catch(err => {
                log.error('could not create a new stream', err);
            });
            const muxer = {
                protocol: 'webtransport',
                streams: activeStreams,
                newStream: async (name) => {
                    log('new outgoing stream', name);
                    const wtStream = await wt.createBidirectionalStream();
                    const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), init?.direction ?? 'outbound', activeStreams, init?.onStreamEnd, logger);
                    activeStreams.push(stream);
                    return stream;
                },
                /**
                 * Close all tracked streams and stop the muxer
                 */
                close: async () => {
                    log('closing webtransport muxer gracefully');
                    try {
                        wt.close();
                    }
                    catch (err) {
                        muxer.abort(err);
                    }
                },
                /**
                 * Abort all tracked streams and stop the muxer
                 */
                abort: (err) => {
                    log('closing webtransport muxer with err:', err);
                    try {
                        wt.close();
                    }
                    catch (err) {
                        log.error('webtransport session threw error during close', err);
                    }
                },
                // This stream muxer is webtransport native. Therefore it doesn't plug in with any other duplex.
                ...inertDuplex()
            };
            return muxer;
        }
    };
}
//# sourceMappingURL=muxer.js.map