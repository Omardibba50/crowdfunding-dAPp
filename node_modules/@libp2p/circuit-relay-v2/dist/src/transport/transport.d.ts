import { serviceCapabilities, serviceDependencies, transportSymbol } from '@libp2p/interface';
import { ReservationStore } from './reservation-store.js';
import type { CircuitRelayTransportComponents, CircuitRelayTransportInit } from './index.js';
import type { Transport, CreateListenerOptions, Listener, Connection, Stream, PeerId, OutboundConnectionUpgradeEvents, DialTransportOptions, OpenConnectionProgressEvents } from '@libp2p/interface';
import type { IncomingStreamData } from '@libp2p/interface-internal';
import type { Multiaddr } from '@multiformats/multiaddr';
import type { ProgressEvent, ProgressOptions } from 'progress-events';
interface ConnectOptions extends ProgressOptions<CircuitRelayDialEvents> {
    stream: Stream;
    connection: Connection;
    destinationPeer: PeerId;
    destinationAddr: Multiaddr;
    relayAddr: Multiaddr;
    ma: Multiaddr;
    disconnectOnFailure: boolean;
}
export type CircuitRelayDialEvents = OutboundConnectionUpgradeEvents | OpenConnectionProgressEvents | ProgressEvent<'circuit-relay:open-connection'> | ProgressEvent<'circuit-relay:reuse-connection'> | ProgressEvent<'circuit-relay:open-hop-stream'> | ProgressEvent<'circuit-relay:write-connect-message'> | ProgressEvent<'circuit-relay:read-connect-response'>;
export declare class CircuitRelayTransport implements Transport<CircuitRelayDialEvents> {
    private readonly discovery?;
    private readonly registrar;
    private readonly peerStore;
    private readonly connectionManager;
    private readonly transportManager;
    private readonly peerId;
    private readonly upgrader;
    private readonly addressManager;
    private readonly connectionGater;
    readonly reservationStore: ReservationStore;
    private readonly logger;
    private readonly maxInboundStopStreams;
    private readonly maxOutboundStopStreams?;
    private readonly stopTimeout;
    private started;
    private readonly log;
    constructor(components: CircuitRelayTransportComponents, init: CircuitRelayTransportInit);
    readonly [Symbol.toStringTag] = "@libp2p/circuit-relay-v2-transport";
    readonly [serviceCapabilities]: string[];
    get [serviceDependencies](): string[];
    readonly [transportSymbol] = true;
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Dial a peer over a relay
     */
    dial(ma: Multiaddr, options: DialTransportOptions<CircuitRelayDialEvents>): Promise<Connection>;
    connectV2({ stream, connection, destinationPeer, destinationAddr, relayAddr, ma, disconnectOnFailure, onProgress }: ConnectOptions): Promise<Connection>;
    /**
     * Create a listener
     */
    createListener(options: CreateListenerOptions): Listener;
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs: Multiaddr[]): Multiaddr[];
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs: Multiaddr[]): Multiaddr[];
    /**
     * An incoming STOP request means a remote peer wants to dial us via a relay
     */
    onStop({ connection, stream }: IncomingStreamData): Promise<void>;
}
export {};
//# sourceMappingURL=transport.d.ts.map