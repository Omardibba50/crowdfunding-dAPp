import { TypedEventEmitter } from '@libp2p/interface';
import type { Reservation } from '../pb/index.js';
import type { TypedEventTarget, Libp2pEvents, ComponentLogger, PeerId, PeerStore, Startable, Metrics } from '@libp2p/interface';
import type { ConnectionManager, TransportManager } from '@libp2p/interface-internal';
export interface RelayStoreComponents {
    peerId: PeerId;
    connectionManager: ConnectionManager;
    transportManager: TransportManager;
    peerStore: PeerStore;
    events: TypedEventTarget<Libp2pEvents>;
    logger: ComponentLogger;
    metrics?: Metrics;
}
export interface RelayStoreInit {
    /**
     * Multiple relays may be discovered simultaneously - to prevent listening
     * on too many relays, this value controls how many to attempt to reserve a
     * slot on at once. If set to more than one, we may end up listening on
     * more relays than the `maxReservations` value, but on networks with poor
     * connectivity the user may wish to attempt to reserve on multiple relays
     * simultaneously. (default: 1)
     */
    reservationConcurrency?: number;
    /**
     * How many discovered relays to allow in the reservation store
     */
    discoverRelays?: number;
    /**
     * Limit the number of potential relays we will dial (default: 100)
     */
    maxReservationQueueLength?: number;
    /**
     * When creating a reservation it must complete within this number of ms
     * (default: 5000)
     */
    reservationCompletionTimeout?: number;
}
export type RelayType = 'discovered' | 'configured';
export interface ReservationStoreEvents {
    'relay:not-enough-relays': CustomEvent;
    'relay:removed': CustomEvent<PeerId>;
    'relay:created-reservation': CustomEvent<PeerId>;
}
export declare class ReservationStore extends TypedEventEmitter<ReservationStoreEvents> implements Startable {
    #private;
    private readonly peerId;
    private readonly connectionManager;
    private readonly transportManager;
    private readonly peerStore;
    private readonly events;
    private readonly reserveQueue;
    private readonly reservations;
    private readonly maxDiscoveredRelays;
    private readonly maxReservationQueueLength;
    private readonly reservationCompletionTimeout;
    private started;
    private readonly log;
    private readonly relayFilter;
    constructor(components: RelayStoreComponents, init?: RelayStoreInit);
    isStarted(): boolean;
    start(): void;
    afterStart(): void;
    stop(): void;
    /**
     * If the number of current relays is beneath the configured `maxReservations`
     * value, and the passed peer id is not our own, and we have a non-relayed
     * connection to the remote, and the remote peer speaks the hop protocol, try
     * to reserve a slot on the remote peer
     */
    addRelay(peerId: PeerId, type: RelayType): Promise<void>;
    hasReservation(peerId: PeerId): boolean;
    getReservation(peerId: PeerId): Reservation | undefined;
    reservationCount(): number;
}
//# sourceMappingURL=reservation-store.d.ts.map