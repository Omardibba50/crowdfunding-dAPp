import { CodeError } from '@libp2p/interface';
import { PeerSet } from '@libp2p/peer-collections';
import merge from 'it-merge';
import { codes, messages } from './errors.js';
export class CompoundContentRouting {
    routers;
    started;
    components;
    constructor(components, init) {
        this.routers = init.routers ?? [];
        this.started = false;
        this.components = components;
    }
    [Symbol.toStringTag] = '@libp2p/content-routing';
    isStarted() {
        return this.started;
    }
    async start() {
        this.started = true;
    }
    async stop() {
        this.started = false;
    }
    /**
     * Iterates over all content routers in parallel to find providers of the given key
     */
    async *findProviders(key, options = {}) {
        if (this.routers.length === 0) {
            throw new CodeError('No content routers available', codes.ERR_NO_ROUTERS_AVAILABLE);
        }
        const self = this;
        const seen = new PeerSet();
        for await (const peer of merge(...self.routers.map(router => router.findProviders(key, options)))) {
            // the peer was yielded by a content router without multiaddrs and we
            // failed to load them
            if (peer == null) {
                continue;
            }
            // store the addresses for the peer if found
            if (peer.multiaddrs.length > 0) {
                await this.components.peerStore.merge(peer.id, {
                    multiaddrs: peer.multiaddrs
                });
            }
            // deduplicate peers
            if (seen.has(peer.id)) {
                continue;
            }
            seen.add(peer.id);
            yield peer;
        }
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */
    async provide(key, options = {}) {
        if (this.routers.length === 0) {
            throw new CodeError('No content routers available', codes.ERR_NO_ROUTERS_AVAILABLE);
        }
        await Promise.all(this.routers.map(async (router) => {
            await router.provide(key, options);
        }));
    }
    /**
     * Store the given key/value pair in the available content routings
     */
    async put(key, value, options) {
        if (!this.isStarted()) {
            throw new CodeError(messages.NOT_STARTED_YET, codes.ERR_NODE_NOT_STARTED);
        }
        await Promise.all(this.routers.map(async (router) => {
            await router.put(key, value, options);
        }));
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */
    async get(key, options) {
        if (!this.isStarted()) {
            throw new CodeError(messages.NOT_STARTED_YET, codes.ERR_NODE_NOT_STARTED);
        }
        return Promise.any(this.routers.map(async (router) => {
            return router.get(key, options);
        }));
    }
}
//# sourceMappingURL=content-routing.js.map