import { unmarshalPublicKey } from '@libp2p/crypto/keys';
import {} from 'uint8arraylist';
import { equals, toString } from 'uint8arrays';
import { concat as uint8ArrayConcat } from 'uint8arrays/concat';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { UnexpectedPeerError } from './errors.js';
import { NoiseHandshakePayload } from './proto/payload.js';
export async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
    const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
    return NoiseHandshakePayload.encode({
        identityKey: privateKey.public.bytes,
        identitySig,
        extensions
    });
}
export async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
    try {
        const payload = NoiseHandshakePayload.decode(payloadBytes);
        if (remoteIdentityKey) {
            const remoteIdentityKeyBytes = remoteIdentityKey.subarray();
            if (!equals(remoteIdentityKeyBytes, payload.identityKey)) {
                throw new Error(`Payload identity key ${toString(payload.identityKey, 'hex')} does not match expected remote identity key ${toString(remoteIdentityKeyBytes, 'hex')}`);
            }
        }
        if (!remoteStaticKey) {
            throw new Error('Remote static does not exist');
        }
        const signaturePayload = getSignaturePayload(remoteStaticKey);
        const publicKey = unmarshalPublicKey(payload.identityKey);
        if (!(await publicKey.verify(signaturePayload, payload.identitySig))) {
            throw new Error('Invalid payload signature');
        }
        return payload;
    }
    catch (e) {
        throw new UnexpectedPeerError(e.message);
    }
}
export function getSignaturePayload(publicKey) {
    const prefix = uint8ArrayFromString('noise-libp2p-static-key:');
    if (publicKey instanceof Uint8Array) {
        return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length);
    }
    publicKey.prepend(prefix);
    return publicKey;
}
//# sourceMappingURL=utils.js.map