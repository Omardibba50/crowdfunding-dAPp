(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ChainsafeLibp2PYamux = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ChainsafeLibp2PYamux=(()=>{var Y=Object.defineProperty;var At=Object.getOwnPropertyDescriptor;var Dt=Object.getOwnPropertyNames;var xt=Object.prototype.hasOwnProperty;var vt=(r,t)=>{for(var e in t)Y(r,e,{get:t[e],enumerable:!0})},Lt=(r,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Dt(t))!xt.call(r,n)&&n!==e&&Y(r,n,{get:()=>t[n],enumerable:!(s=At(t,n))||s.enumerable});return r};var Ct=r=>Lt(Y({},"__esModule",{value:!0}),r);var Xt={};vt(Xt,{GoAwayCode:()=>m,yamux:()=>Bt});var a=class extends Error{code;props;constructor(t,e,s){super(t),this.code=e,this.name=s?.name??"CodeError",this.props=s??{}}};var H=(r,...t)=>{try{[...t]}catch{}};function W(r){if(r!=null){if(typeof r[Symbol.iterator]=="function")return r[Symbol.iterator]();if(typeof r[Symbol.asyncIterator]=="function")return r[Symbol.asyncIterator]();if(typeof r.next=="function")return r}throw new Error("argument is not an iterator or iterable")}function y(){let r={};return r.promise=new Promise((t,e)=>{r.resolve=t,r.reject=e}),r}var M=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},x=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new M(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new M(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var q=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function k(r={}){return Tt(e=>{let s=e.shift();if(s==null)return{done:!0};if(s.error!=null)throw s.error;return{done:s.done===!0,value:s.value}},r)}function Tt(r,t){t=t??{};let e=t.onEnd,s=new x,n,i,o,l=y(),u=async()=>{try{return s.isEmpty()?o?{done:!0}:await new Promise((h,I)=>{i=U=>{i=null,s.push(U);try{h(r(s))}catch(D){I(D)}return n}}):r(s)}finally{s.isEmpty()&&queueMicrotask(()=>{l.resolve(),l=y()})}},w=h=>i!=null?i(h):(s.push(h),n),b=h=>(s=new x,i!=null?i({error:h}):(s.push({error:h}),n)),d=h=>{if(o)return n;if(t?.objectMode!==!0&&h?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return w({done:!1,value:h})},p=h=>o?n:(o=!0,h!=null?b(h):w({done:!0})),O=()=>(s=new x,p(),{done:!0}),_t=h=>(p(h),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:u,return:O,throw:_t,push:d,end:p,get readableLength(){return s.size},onEmpty:async h=>{let I=h?.signal;if(I?.throwIfAborted(),s.isEmpty())return;let U,D;I!=null&&(U=new Promise((zt,It)=>{D=()=>{It(new q)},I.addEventListener("abort",D)}));try{await Promise.race([l.promise,U])}finally{D!=null&&I!=null&&I?.removeEventListener("abort",D)}}},e==null)return n;let A=n;return n={[Symbol.asyncIterator](){return this},next(){return A.next()},throw(h){return A.throw(h),e!=null&&(e(h),e=void 0),{done:!0}},return(){return A.return(),e!=null&&(e(),e=void 0),{done:!0}},push:d,end(h){return A.end(h),e!=null&&(e(h),e=void 0),n},get readableLength(){return A.readableLength},onEmpty:h=>A.onEmpty(h)},n}function v(r){return globalThis.Buffer!=null?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r}function E(r=0){return globalThis.Buffer?.alloc!=null?v(globalThis.Buffer.alloc(r)):new Uint8Array(r)}function C(r=0){return globalThis.Buffer?.allocUnsafe!=null?v(globalThis.Buffer.allocUnsafe(r)):new Uint8Array(r)}function K(r,t){if(globalThis.Buffer!=null)return v(globalThis.Buffer.concat(r,t));t==null&&(t=r.reduce((n,i)=>n+i.length,0));let e=C(t),s=0;for(let n of r)e.set(n,s),s+=n.length;return v(e)}function it(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}var at=Symbol.for("@achingbrain/uint8arraylist");function ot(r,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let s of r){let n=e+s.byteLength;if(t<n)return{buf:s,index:t-e};e=n}throw new RangeError("index is out of bounds")}function P(r){return!!r?.[at]}var S=class r{bufs;length;[at]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let s of t)if(s instanceof Uint8Array)e+=s.byteLength,this.bufs.push(s);else if(P(s))e+=s.byteLength,this.bufs.push(...s.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let s of t.reverse())if(s instanceof Uint8Array)e+=s.byteLength,this.bufs.unshift(s);else if(P(s))e+=s.byteLength,this.bufs.unshift(...s.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=ot(this.bufs,t);return e.buf[e.index]}set(t,e){let s=ot(this.bufs,t);s.buf[s.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let s=0;s<t.length;s++)this.set(e+s,t[s]);else if(P(t))for(let s=0;s<t.length;s++)this.set(e+s,t.get(s));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:s,length:n}=this._subList(t,e);return K(s,n)}subarray(t,e){let{bufs:s,length:n}=this._subList(t,e);return s.length===1?s[0]:K(s,n)}sublist(t,e){let{bufs:s,length:n}=this._subList(t,e),i=new r;return i.length=n,i.bufs=[...s],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let s=[],n=0;for(let i=0;i<this.bufs.length;i++){let o=this.bufs[i],l=n,u=l+o.byteLength;if(n=u,t>=u)continue;let w=t>=l&&t<u,b=e>l&&e<=u;if(w&&b){if(t===l&&e===u){s.push(o);break}let d=t-l;s.push(o.subarray(d,d+(e-t)));break}if(w){if(t===0){s.push(o);continue}s.push(o.subarray(t-l));continue}if(b){if(e===u){s.push(o);break}s.push(o.subarray(0,e-l));break}s.push(o)}return{bufs:s,length:e-t}}indexOf(t,e=0){if(!P(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let s=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let n=s.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<n;d++)o[s[d]]=d;let l=o,u=this.byteLength-s.byteLength,w=s.byteLength-1,b;for(let d=e;d<=u;d+=b){b=0;for(let p=w;p>=0;p--){let O=this.get(d+p);if(s[p]!==O){b=Math.max(1,p-l[O]);break}}if(b===0)return d}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let s=C(1);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt8(0,e),this.write(s,t)}getInt16(t,e){let s=this.subarray(t,t+2);return new DataView(s.buffer,s.byteOffset,s.byteLength).getInt16(0,e)}setInt16(t,e,s){let n=E(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,e,s),this.write(n,t)}getInt32(t,e){let s=this.subarray(t,t+4);return new DataView(s.buffer,s.byteOffset,s.byteLength).getInt32(0,e)}setInt32(t,e,s){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,e,s),this.write(n,t)}getBigInt64(t,e){let s=this.subarray(t,t+8);return new DataView(s.buffer,s.byteOffset,s.byteLength).getBigInt64(0,e)}setBigInt64(t,e,s){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,e,s),this.write(n,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let s=C(1);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint8(0,e),this.write(s,t)}getUint16(t,e){let s=this.subarray(t,t+2);return new DataView(s.buffer,s.byteOffset,s.byteLength).getUint16(0,e)}setUint16(t,e,s){let n=E(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,e,s),this.write(n,t)}getUint32(t,e){let s=this.subarray(t,t+4);return new DataView(s.buffer,s.byteOffset,s.byteLength).getUint32(0,e)}setUint32(t,e,s){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,e,s),this.write(n,t)}getBigUint64(t,e){let s=this.subarray(t,t+8);return new DataView(s.buffer,s.byteOffset,s.byteLength).getBigUint64(0,e)}setBigUint64(t,e,s){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,e,s),this.write(n,t)}getFloat32(t,e){let s=this.subarray(t,t+4);return new DataView(s.buffer,s.byteOffset,s.byteLength).getFloat32(0,e)}setFloat32(t,e,s){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,e,s),this.write(n,t)}getFloat64(t,e){let s=this.subarray(t,t+8);return new DataView(s.buffer,s.byteOffset,s.byteLength).getFloat64(0,e)}setFloat64(t,e,s){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,e,s),this.write(n,t)}equals(t){if(t==null||!(t instanceof r)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!it(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let s=new r;return s.bufs=t,e==null&&(e=t.reduce((n,i)=>n+i.byteLength,0)),s.length=e,s}};var L="ERR_INVALID_FRAME",$="ERR_UNREQUESTED_PING",Q="ERR_NOT_MATCHING_PING",j="ERR_STREAM_ALREADY_EXISTS",J="ERR_DECODE_INVALID_VERSION",Z="ERR_BOTH_CLIENTS",tt="ERR_RECV_WINDOW_EXCEEDED",lt=new Set([L,$,Q,j,J,Z,tt]),R="ERR_INVALID_CONFIG",V="ERR_MUXER_LOCAL_CLOSED",et="ERR_MUXER_REMOTE_CLOSED";var ht="ERR_STREAM_ABORT",ut="ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED",ct="ERR_DECODE_IN_PROGRESS",T=256*1024,ft=16*1024*1024;var dt={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:T,maxStreamWindowSize:ft,maxMessageSize:64*1024};function mt(r){if(r.keepAliveInterval<=0)throw new a("keep-alive interval must be positive",R);if(r.maxInboundStreams<0)throw new a("max inbound streams must be larger or equal 0",R);if(r.maxOutboundStreams<0)throw new a("max outbound streams must be larger or equal 0",R);if(r.initialStreamWindowSize<T)throw new a("InitialStreamWindowSize must be larger or equal 256 kB",R);if(r.maxStreamWindowSize<r.initialStreamWindowSize)throw new a("MaxStreamWindowSize must be larger than the InitialStreamWindowSize",R);if(r.maxStreamWindowSize>2**32-1)throw new a("MaxStreamWindowSize must be less than equal MAX_UINT32",R);if(r.maxMessageSize<1024)throw new a("MaxMessageSize must be greater than a kilobyte",R)}var f;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(f||(f={}));var c;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(c||(c={}));var ge=Object.values(c).filter(r=>typeof r!="string"),gt=0,m;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(m||(m={}));var _=12;var wt=2**24;function Nt(r){if(r[0]!==gt)throw new a("Invalid frame version",J);return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*wt+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*wt+(r[9]<<16)+(r[10]<<8)+r[11]}}var F=class{source;buffer;frameInProgress;constructor(t){this.source=Ot(t),this.buffer=new S,this.frameInProgress=!1}async*emitFrames(){for await(let t of this.source)for(this.buffer.append(t);;){let e=this.readHeader();if(e===void 0)break;let{type:s,length:n}=e;s===f.Data?(this.frameInProgress=!0,yield{header:e,readData:this.readBytes.bind(this,n)}):yield{header:e}}}readHeader(){if(this.frameInProgress)throw new a("decoding frame already in progress",ct);if(this.buffer.length<_)return;let t=Nt(this.buffer.subarray(0,_));return this.buffer.consume(_),t}async readBytes(t){if(this.buffer.length<t){for await(let s of this.source)if(this.buffer.append(s),this.buffer.length>=t)break}let e=this.buffer.sublist(0,t);return this.buffer.consume(t),this.frameInProgress=!1,e}};function Ot(r){if(r[Symbol.iterator]!==void 0){let t=r[Symbol.iterator]();return t.return=void 0,{[Symbol.iterator](){return t}}}else if(r[Symbol.asyncIterator]!==void 0){let t=r[Symbol.asyncIterator]();return t.return=void 0,{[Symbol.asyncIterator](){return t}}}else throw new Error("a source must be either an iterable or an async iterable")}function st(r){let t=new Uint8Array(_);return t[1]=r.type,t[2]=r.flag>>>8,t[3]=r.flag,t[4]=r.streamID>>>24,t[5]=r.streamID>>>16,t[6]=r.streamID>>>8,t[7]=r.streamID,t[8]=r.length>>>24,t[9]=r.length>>>16,t[10]=r.length>>>8,t[11]=r.length,t}var G=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=e??"ABORT_ERR"}};async function N(r,t,e){if(t==null)return r;if(t.aborted)return Promise.reject(new G(e?.errorMessage,e?.errorCode));let s,n=new G(e?.errorMessage,e?.errorCode);try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n)},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}function bt(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function pt(r,t){let e=W(r).return?.();bt(e)&&e.catch(s=>{t.error("could not cause iterator to return",s)})}var Ut="ERR_STREAM_RESET",Wt="ERR_SINK_INVALID_STATE",Mt=5e3;function rt(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}var B=class{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(t){this.sinkController=new AbortController,this.sinkEnd=y(),this.closed=y(),this.log=t.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=t.id,this.metadata=t.metadata??{},this.direction=t.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=t.sendCloseWriteTimeout??Mt,this.onEnd=t.onEnd,this.onCloseRead=t?.onCloseRead,this.onCloseWrite=t?.onCloseWrite,this.onReset=t?.onReset,this.onAbort=t?.onAbort,this.source=this.streamSource=k({onEnd:e=>{e!=null?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(t){if(this.writeStatus!=="ready")throw new a(`writable end state is "${this.writeStatus}" not "ready"`,Wt);try{this.writeStatus="writing";let e={signal:this.sinkController.signal};if(this.direction==="outbound"){let n=this.sendNewStream(e);rt(n)&&await n}let s=()=>{pt(t,this.log)};try{this.sinkController.signal.addEventListener("abort",s),this.log.trace("sink reading from source");for await(let n of t){n=n instanceof Uint8Array?new S(n):n;let i=this.sendData(n,e);rt(i)&&(this.sendingData=y(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",s)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(t){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(t){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(t){this.log.trace("closing gracefully"),this.status="closing",await N(Promise.all([this.closeWrite(t),this.closeRead(t),this.closed.promise]),t?.signal),this.status="closed",this.log.trace("closed gracefully")}async closeRead(t={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);let e=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(t)),e==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(t={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await N(this.sink([]),t.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await N(this.sendingData.promise,t.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await N(this.sinkEnd.promise,t.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(t){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",t),this.log("try to send reset to remote");let e=this.sendReset();rt(e)&&e.catch(s=>{this.log.error("error sending reset message",s)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(t),this.onAbort?.(t)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;let t=new a("stream reset",Ut);this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(t),this.onReset?.()}_closeSinkAndSource(t){this._closeSink(t),this._closeSource(t)}_closeSink(t){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(t)}_closeSource(t){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(t))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(t){this.streamSource.push(t)}sourceReadableLength(){return this.streamSource.readableLength}};function kt(r){let[t,e]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],s=[];return{peek:()=>t.next(),push:n=>{s.push(n)},next:()=>s.length>0?{done:!1,value:s.shift()}:t.next(),[e](){return this}}}var yt=kt;function Pt(r){return r[Symbol.asyncIterator]!=null}function Et(r){return r?.then!=null}function Vt(r,t){if(Pt(r))return async function*(){for await(let l of r){let u=t(l);Et(u)&&await u,yield l}}();let e=yt(r),{value:s,done:n}=e.next();if(n===!0)return function*(){}();if(typeof t(s)?.then=="function")return async function*(){yield s;for await(let l of e){let u=t(l);Et(u)&&await u,yield l}}();let o=t;return function*(){yield s;for(let l of e)o(l),yield l}()}var St=Vt;var g;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished"})(g||(g={}));var X=class extends B{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(t){super({...t,onEnd:e=>{this.state=g.Finished,t.onEnd?.(e)}}),this.config=t.config,this._id=parseInt(t.id,10),this.name=t.name,this.state=t.state,this.sendWindowCapacity=T,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame,this.source=St(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(t,e={}){for(t=t.sublist();t.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(e),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}let s=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-_,t.length),n=this.getSendFlags();this.sendFrame({type:f.Data,flag:n,streamID:this._id,length:s},t.sublist(0,s)),this.sendWindowCapacity-=s,t.consume(s)}}async sendReset(){this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:this._id,length:0})}async sendCloseWrite(){let t=this.getSendFlags()|c.FIN;this.sendFrame({type:f.WindowUpdate,flag:t,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(t={}){if(this.sendWindowCapacity>0)return;let e,s,n=()=>{this.status==="open"||this.status==="closing"?s(new a("stream aborted",ht)):e()};t.signal?.addEventListener("abort",n);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},s=o,e=i})}finally{t.signal?.removeEventListener("abort",n)}}handleWindowUpdate(t){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(t.flag);let e=this.sendWindowCapacity;this.sendWindowCapacity+=t.length,e===0&&t.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(t,e){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(t.flag),this.recvWindowCapacity<t.length)throw new a("receive window exceeded",tt,{available:this.recvWindowCapacity,recv:t.length});let s=await e();this.recvWindowCapacity-=t.length,this.sourcePush(s)}processFlags(t){(t&c.ACK)===c.ACK&&this.state===g.SYNSent&&(this.state=g.Established),(t&c.FIN)===c.FIN&&this.remoteCloseWrite(),(t&c.RST)===c.RST&&this.reset()}getSendFlags(){switch(this.state){case g.Init:return this.state=g.SYNSent,c.SYN;case g.SYNReceived:return this.state=g.Established,c.ACK;default:return 0}}sendWindowUpdate(){let t=this.getSendFlags(),e=Date.now(),s=this.getRTT();if(t===0&&s>-1&&e-this.epochStart<s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;let n=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=e,this.sendFrame({type:f.WindowUpdate,flag:t,streamID:this._id,length:n})}};var Rt="/yamux/1.0.0",Ft=500,z=class{protocol=Rt;_components;_init;constructor(t,e={}){this._components=t,this._init=e}createStreamMuxer(t){return new nt(this._components,{...this._init,...t})}},nt=class{protocol=Rt;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(t,e){this.client=e.direction==="outbound",this.config={...dt,...e},this.logger=t.logger,this.log=this.logger.forComponent("libp2p:yamux"),mt(this.config),this.closeController=new AbortController,H(1/0,this.closeController.signal),this.onIncomingStream=e.onIncomingStream,this.onStreamEnd=e.onStreamEnd,this._streams=new Map,this.source=k({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(s=>{s.destroy()})}}),this.sink=async s=>{let n=()=>{let l=W(s);if(l.return!=null){let u=l.return();Gt(u)&&u.catch(w=>{this.log?.("could not cause sink source to return",w)})}},i,o;try{let l=new F(s);try{this.closeController.signal.addEventListener("abort",n);for await(let u of l.emitFrames())await this.handleFrame(u.header,u.readData)}finally{this.closeController.signal.removeEventListener("abort",n)}i=m.NormalTermination}catch(l){let u=l.code;lt.has(u)?(this.log?.error("protocol error in sink",l),i=m.ProtocolError):(this.log?.error("internal error in sink",l),i=m.InternalError),o=l}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(s=>this.log?.error("keepalive error: %s",s)),this.ping().catch(s=>this.log?.error("ping error: %s",s))}get streams(){return Array.from(this._streams.values())}newStream(t){if(this.remoteGoAway!==void 0)throw new a("muxer closed remotely",et);if(this.localGoAway!==void 0)throw new a("muxer closed locally",V);let e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new a("max outbound streams exceeded",ut);this.log?.trace("new outgoing stream id=%s",e);let s=this._newStream(e,t,g.Init,"outbound");return this._streams.set(e,s),this.numOutboundStreams++,s.sendWindowUpdate(),s}async ping(){if(this.remoteGoAway!==void 0)throw new a("muxer closed remotely",et);if(this.localGoAway!==void 0)throw new a("muxer closed locally",V);if(this.activePing===void 0){let t=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((n,i)=>{let o=()=>{i(new a("muxer closed locally",V))};this.closeController.signal.addEventListener("abort",o,{once:!0}),t=()=>{this.closeController.signal.removeEventListener("abort",o),n()}}),resolve:t};let e=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}let s=Date.now();this.rtt=s-e}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(t={}){if(this.closeController.signal.aborted)return;let e=t?.reason??m.NormalTermination;if(this.log?.trace("muxer close reason=%s",e),t.signal==null){let s=AbortSignal.timeout(Ft);H(1/0,s),t={...t,signal:s}}try{await Promise.all([...this._streams.values()].map(async s=>s.close(t))),this.sendGoAway(e),this._closeMuxer()}catch(s){this.abort(s)}}abort(t,e){if(!this.closeController.signal.aborted){e=e??m.InternalError,this.log?.error("muxer abort reason=%s error=%s",e,t);for(let s of this._streams.values())s.abort(t);this.sendGoAway(e),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(t,e,s,n){if(this._streams.get(t)!=null)throw new a("Stream already exists",j,{id:t});let i=new X({id:t.toString(),name:e,state:s,direction:n,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(t),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${n}:${t}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(t)}async keepAliveLoop(){let t=new Promise((e,s)=>{this.closeController.signal.addEventListener("abort",s,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let e;try{await Promise.race([t,new Promise(s=>{e=setTimeout(s,this.config.keepAliveInterval)})]),this.ping().catch(s=>this.log?.error("ping error: %s",s))}catch{clearInterval(e);return}}}async handleFrame(t,e){let{streamID:s,type:n,length:i}=t;if(this.log?.trace("received frame %o",t),s===0)switch(n){case f.Ping:{this.handlePing(t);return}case f.GoAway:{this.handleGoAway(i);return}default:throw new a("Invalid frame type",L,{header:t})}else switch(t.type){case f.Data:case f.WindowUpdate:{await this.handleStreamMessage(t,e);return}default:throw new a("Invalid frame type",L,{header:t})}}handlePing(t){if(t.flag===c.SYN)this.log?.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,c.ACK);else if(t.flag===c.ACK)this.log?.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new a("Invalid frame flag",L,{header:t})}handlePingResponse(t){if(this.activePing===void 0)throw new a("ping not requested",$);if(this.activePing.id!==t)throw new a("ping doesn't match our id",Q);this.activePing.resolve()}handleGoAway(t){this.log?.trace("received GoAway reason=%s",m[t]??"unknown"),this.remoteGoAway=t;for(let e of this._streams.values())e.reset();this._closeMuxer()}async handleStreamMessage(t,e){let{streamID:s,flag:n,type:i}=t;(n&c.SYN)===c.SYN&&this.incomingStream(s);let o=this._streams.get(s);if(o===void 0){if(i===f.Data){if(this.log?.("discarding data for stream id=%s",s),e===void 0)throw new Error("unreachable");await e()}else this.log?.("frame for missing stream id=%s",s);return}switch(i){case f.WindowUpdate:{o.handleWindowUpdate(t);return}case f.Data:{if(e===void 0)throw new Error("unreachable");await o.handleData(t,e);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new a("both endpoints are clients",Z);if(this._streams.has(t))return;if(this.log?.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:t,length:0});return}let e=this._newStream(t,void 0,g.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(t,e),this.onIncomingStream?.(e)}sendFrame(t,e){if(this.log?.trace("sending frame %o",t),t.type===f.Data){if(e===void 0)throw new a("invalid frame",L);this.source.push(new S(st(t),e))}else this.source.push(st(t))}sendPing(t,e=c.SYN){e===c.SYN?this.log?.trace("sending ping request pingId=%s",t):this.log?.trace("sending ping response pingId=%s",t),this.sendFrame({type:f.Ping,flag:e,streamID:0,length:t})}sendGoAway(t=m.NormalTermination){this.log?.("sending GoAway reason=%s",m[t]),this.localGoAway=t,this.sendFrame({type:f.GoAway,flag:0,streamID:0,length:t})}};function Gt(r){return r!=null&&typeof r.then=="function"}function Bt(r={}){return t=>new z(t,r)}return Ct(Xt);})();
return ChainsafeLibp2PYamux}));
