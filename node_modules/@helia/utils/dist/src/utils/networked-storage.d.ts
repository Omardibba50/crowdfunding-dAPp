import { type ProgressOptions } from 'progress-events';
import type { BlockBroker, Blocks, Pair, DeleteManyBlocksProgressEvents, DeleteBlockProgressEvents, GetBlockProgressEvents, GetManyBlocksProgressEvents, PutManyBlocksProgressEvents, PutBlockProgressEvents, GetAllBlocksProgressEvents, GetOfflineOptions, BlockRetrievalOptions, CreateSessionOptions, SessionBlockstore } from '@helia/interface/blocks';
import type { AbortOptions, ComponentLogger, Logger, Startable } from '@libp2p/interface';
import type { Blockstore } from 'interface-blockstore';
import type { AwaitIterable } from 'interface-store';
import type { CID } from 'multiformats/cid';
import type { MultihashHasher } from 'multiformats/hashes/interface';
export interface GetOptions extends AbortOptions {
    progress?(evt: Event): void;
}
export interface StorageComponents {
    blockstore: Blockstore;
    logger: ComponentLogger;
    blockBrokers: BlockBroker[];
    hashers: Record<number, MultihashHasher>;
}
declare class Storage implements Blockstore {
    protected readonly child: Blockstore;
    protected readonly hashers: Record<number, MultihashHasher>;
    protected log: Logger;
    protected readonly logger: ComponentLogger;
    protected readonly components: StorageComponents;
    /**
     * Create a new BlockStorage
     */
    constructor(components: StorageComponents);
    /**
     * Put a block to the underlying datastore
     */
    put(cid: CID, block: Uint8Array, options?: AbortOptions & ProgressOptions<PutBlockProgressEvents>): Promise<CID>;
    /**
     * Put a multiple blocks to the underlying datastore
     */
    putMany(blocks: AwaitIterable<{
        cid: CID;
        block: Uint8Array;
    }>, options?: AbortOptions & ProgressOptions<PutManyBlocksProgressEvents>): AsyncIterable<CID>;
    /**
     * Get a block by cid
     */
    get(cid: CID, options?: GetOfflineOptions & AbortOptions & ProgressOptions<GetBlockProgressEvents>): Promise<Uint8Array>;
    /**
     * Get multiple blocks back from an (async) iterable of cids
     */
    getMany(cids: AwaitIterable<CID>, options?: GetOfflineOptions & AbortOptions & ProgressOptions<GetManyBlocksProgressEvents>): AsyncIterable<Pair>;
    /**
     * Delete a block from the blockstore
     */
    delete(cid: CID, options?: AbortOptions & ProgressOptions<DeleteBlockProgressEvents>): Promise<void>;
    /**
     * Delete multiple blocks from the blockstore
     */
    deleteMany(cids: AwaitIterable<CID>, options?: AbortOptions & ProgressOptions<DeleteManyBlocksProgressEvents>): AsyncIterable<CID>;
    has(cid: CID, options?: AbortOptions): Promise<boolean>;
    getAll(options?: AbortOptions & ProgressOptions<GetAllBlocksProgressEvents>): AwaitIterable<Pair>;
}
export type NetworkedStorageComponents = StorageComponents;
/**
 * Networked storage wraps a regular blockstore - when getting blocks if the
 * blocks are not present, the configured BlockBrokers will be used to fetch them.
 */
export declare class NetworkedStorage extends Storage implements Blocks, Startable {
    private started;
    /**
     * Create a new BlockStorage
     */
    constructor(components: NetworkedStorageComponents);
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    unwrap(): Blockstore;
    createSession(root: CID, options?: CreateSessionOptions): SessionBlockstore;
}
export declare const getCidBlockVerifierFunction: (cid: CID, hasher: MultihashHasher) => Required<BlockRetrievalOptions>['validateFn'];
export {};
//# sourceMappingURL=networked-storage.d.ts.map