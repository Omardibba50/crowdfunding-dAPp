import type { Routing as RoutingInterface, Provider, RoutingOptions } from '@helia/interface';
import type { AbortOptions, ComponentLogger, PeerId, PeerInfo, Startable } from '@libp2p/interface';
import type { CID } from 'multiformats/cid';
export interface RoutingInit {
    routers: Array<Partial<RoutingInterface>>;
    providerLookupConcurrency?: number;
}
export interface RoutingComponents {
    logger: ComponentLogger;
}
export declare class Routing implements RoutingInterface, Startable {
    private readonly log;
    private readonly routers;
    private readonly providerLookupConcurrency;
    constructor(components: RoutingComponents, init: RoutingInit);
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Iterates over all content routers in parallel to find providers of the
     * given key
     */
    findProviders(key: CID, options?: RoutingOptions): AsyncIterable<Provider>;
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */
    provide(key: CID, options?: AbortOptions): Promise<void>;
    /**
     * Store the given key/value pair in the available content routings
     */
    put(key: Uint8Array, value: Uint8Array, options?: AbortOptions): Promise<void>;
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */
    get(key: Uint8Array, options?: AbortOptions): Promise<Uint8Array>;
    /**
     * Iterates over all peer routers in parallel to find the given peer
     */
    findPeer(id: PeerId, options?: RoutingOptions): Promise<PeerInfo>;
    /**
     * Attempt to find the closest peers on the network to the given key
     */
    getClosestPeers(key: Uint8Array, options?: RoutingOptions): AsyncIterable<PeerInfo>;
}
//# sourceMappingURL=routing.d.ts.map