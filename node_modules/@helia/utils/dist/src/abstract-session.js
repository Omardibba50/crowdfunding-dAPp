import { DEFAULT_SESSION_MIN_PROVIDERS, DEFAULT_SESSION_MAX_PROVIDERS } from '@helia/interface';
import { CodeError, TypedEventEmitter, setMaxListeners } from '@libp2p/interface';
import { Queue } from '@libp2p/utils/queue';
import { base64 } from 'multiformats/bases/base64';
import pDefer from 'p-defer';
import { BloomFilter } from './bloom-filter.js';
export class AbstractSession extends TypedEventEmitter {
    intialPeerSearchComplete;
    requests;
    name;
    log;
    logger;
    minProviders;
    maxProviders;
    providers;
    evictionFilter;
    constructor(components, init) {
        super();
        setMaxListeners(Infinity, this);
        this.name = init.name;
        this.logger = components.logger;
        this.log = components.logger.forComponent(this.name);
        this.requests = new Map();
        this.minProviders = init.minProviders ?? DEFAULT_SESSION_MIN_PROVIDERS;
        this.maxProviders = init.maxProviders ?? DEFAULT_SESSION_MAX_PROVIDERS;
        this.providers = [];
        this.evictionFilter = BloomFilter.create(this.maxProviders);
    }
    async retrieve(cid, options = {}) {
        // see if we are already requesting this CID in this session
        const cidStr = base64.encode(cid.multihash.bytes);
        const existingJob = this.requests.get(cidStr);
        if (existingJob != null) {
            this.log('join existing request for %c', cid);
            return existingJob;
        }
        const deferred = pDefer();
        this.requests.set(cidStr, deferred.promise);
        if (this.providers.length === 0) {
            let first = false;
            if (this.intialPeerSearchComplete == null) {
                first = true;
                this.log = this.logger.forComponent(`${this.name}:${cid}`);
                this.intialPeerSearchComplete = this.findProviders(cid, this.minProviders, options);
            }
            await this.intialPeerSearchComplete;
            if (first) {
                this.log('found initial session peers for %c', cid);
            }
        }
        let foundBlock = false;
        // this queue manages outgoing requests - as new peers are added to the
        // session they will be added to the queue so we can request the current
        // block from multiple peers as they are discovered
        const queue = new Queue({
            concurrency: this.maxProviders
        });
        queue.addEventListener('error', () => { });
        queue.addEventListener('failure', (evt) => {
            this.log.error('error querying provider %o, evicting from session', evt.detail.job.options.provider, evt.detail.error);
            this.evict(evt.detail.job.options.provider);
        });
        queue.addEventListener('success', (evt) => {
            // peer has sent block, return it to the caller
            foundBlock = true;
            deferred.resolve(evt.detail.result);
        });
        queue.addEventListener('idle', () => {
            if (foundBlock || options.signal?.aborted === true) {
                // we either found the block or the user gave up
                return;
            }
            // find more session peers and retry
            Promise.resolve()
                .then(async () => {
                this.log('no session peers had block for for %c, finding new providers', cid);
                // evict this.minProviders random providers to make room for more
                for (let i = 0; i < this.minProviders; i++) {
                    if (this.providers.length === 0) {
                        break;
                    }
                    const provider = this.providers[Math.floor(Math.random() * this.providers.length)];
                    this.evict(provider);
                }
                // find new providers for the CID
                await this.findProviders(cid, this.minProviders, options);
                // keep trying until the abort signal fires
                this.log('found new providers re-retrieving %c', cid);
                this.requests.delete(cidStr);
                deferred.resolve(await this.retrieve(cid, options));
            })
                .catch(err => {
                this.log.error('could not find new providers for %c', cid, err);
                deferred.reject(err);
            });
        });
        const peerAddedToSessionListener = (event) => {
            queue.add(async () => {
                return this.queryProvider(cid, event.detail, options);
            }, {
                provider: event.detail
            })
                .catch(err => {
                if (options.signal?.aborted === true) {
                    // skip logging error if signal was aborted because abort can happen
                    // on success (e.g. another session found the block)
                    return;
                }
                this.log.error('error retrieving session block for %c', cid, err);
            });
        };
        // add new session peers to query as they are discovered
        this.addEventListener('provider', peerAddedToSessionListener);
        // query each session peer directly
        Promise.all([...this.providers].map(async (provider) => {
            return queue.add(async () => {
                return this.queryProvider(cid, provider, options);
            }, {
                provider
            });
        }))
            .catch(err => {
            if (options.signal?.aborted === true) {
                // skip logging error if signal was aborted because abort can happen
                // on success (e.g. another session found the block)
                return;
            }
            this.log.error('error retrieving session block for %c', cid, err);
        });
        try {
            return await deferred.promise;
        }
        finally {
            this.removeEventListener('provider', peerAddedToSessionListener);
            queue.clear();
            this.requests.delete(cidStr);
        }
    }
    evict(provider) {
        this.evictionFilter.add(this.toEvictionKey(provider));
        const index = this.providers.findIndex(prov => this.equals(prov, provider));
        if (index === -1) {
            return;
        }
        this.providers.splice(index, 1);
    }
    isEvicted(provider) {
        return this.evictionFilter.has(this.toEvictionKey(provider));
    }
    hasProvider(provider) {
        // dedupe existing gateways
        if (this.providers.find(prov => this.equals(prov, provider)) != null) {
            return true;
        }
        // dedupe failed session peers
        if (this.isEvicted(provider)) {
            return true;
        }
        return false;
    }
    async findProviders(cid, count, options) {
        const deferred = pDefer();
        let found = 0;
        // run async to resolve the deferred promise when `count` providers are
        // found but continue util this.providers reaches this.maxProviders
        void Promise.resolve()
            .then(async () => {
            this.log('finding %d-%d new provider(s) for %c', count, this.maxProviders, cid);
            for await (const provider of this.findNewProviders(cid, options)) {
                if (found === this.maxProviders || options.signal?.aborted === true) {
                    break;
                }
                if (this.hasProvider(provider)) {
                    continue;
                }
                this.log('found %d/%d new providers', found, this.maxProviders);
                this.providers.push(provider);
                // let the new peer join current queries
                this.safeDispatchEvent('provider', {
                    detail: provider
                });
                found++;
                if (found === count) {
                    this.log('session is ready');
                    deferred.resolve();
                    // continue finding peers until we reach this.maxProviders
                }
                if (this.providers.length === this.maxProviders) {
                    this.log('found max session peers', found);
                    break;
                }
            }
            this.log('found %d/%d new session peers', found, this.maxProviders);
            if (found < count) {
                throw new CodeError(`Found ${found} of ${count} ${this.name} providers for ${cid}`, 'ERR_INSUFFICIENT_PROVIDERS_FOUND');
            }
        })
            .catch(err => {
            this.log.error('error searching routing for potential session peers for %c', cid, err.errors ?? err);
            deferred.reject(err);
        });
        return deferred.promise;
    }
}
//# sourceMappingURL=abstract-session.js.map