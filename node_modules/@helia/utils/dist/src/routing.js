import { CodeError, start, stop } from '@libp2p/interface';
import { PeerQueue } from '@libp2p/utils/peer-queue';
import merge from 'it-merge';
const DEFAULT_PROVIDER_LOOKUP_CONCURRENCY = 5;
export class Routing {
    log;
    routers;
    providerLookupConcurrency;
    constructor(components, init) {
        this.log = components.logger.forComponent('helia:routing');
        this.routers = init.routers ?? [];
        this.providerLookupConcurrency = init.providerLookupConcurrency ?? DEFAULT_PROVIDER_LOOKUP_CONCURRENCY;
    }
    async start() {
        await start(...this.routers);
    }
    async stop() {
        await stop(...this.routers);
    }
    /**
     * Iterates over all content routers in parallel to find providers of the
     * given key
     */
    async *findProviders(key, options = {}) {
        if (this.routers.length === 0) {
            throw new CodeError('No content routers available', 'ERR_NO_ROUTERS_AVAILABLE');
        }
        // provider multiaddrs are only cached for a limited time, so they can come
        // back as an empty array - when this happens we have to do a FIND_PEER
        // query to get updated addresses, but we shouldn't block on this so use a
        // separate bounded queue to perform this lookup
        const queue = new PeerQueue({
            concurrency: this.providerLookupConcurrency
        });
        queue.addEventListener('error', () => { });
        for await (const peer of merge(queue.toGenerator(), ...supports(this.routers, 'findProviders')
            .map(router => router.findProviders(key, options)))) {
            // the peer was yielded by a content router without multiaddrs and we
            // failed to load them
            if (peer == null) {
                continue;
            }
            // have to refresh peer info for this peer to get updated multiaddrs
            if (peer.multiaddrs.length === 0) {
                // already looking this peer up
                if (queue.find(peer.id) != null) {
                    continue;
                }
                queue.add(async () => {
                    try {
                        const provider = await this.findPeer(peer.id, options);
                        if (provider.multiaddrs.length === 0) {
                            return null;
                        }
                        return provider;
                    }
                    catch (err) {
                        this.log.error('could not load multiaddrs for peer %p', peer.id, err);
                        return null;
                    }
                }, {
                    peerId: peer.id,
                    signal: options.signal
                })
                    .catch(err => {
                    this.log.error('could not load multiaddrs for peer %p', peer.id, err);
                });
            }
            yield peer;
        }
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */
    async provide(key, options = {}) {
        if (this.routers.length === 0) {
            throw new CodeError('No content routers available', 'ERR_NO_ROUTERS_AVAILABLE');
        }
        await Promise.all(supports(this.routers, 'provide')
            .map(async (router) => {
            await router.provide(key, options);
        }));
    }
    /**
     * Store the given key/value pair in the available content routings
     */
    async put(key, value, options) {
        await Promise.all(supports(this.routers, 'put')
            .map(async (router) => {
            await router.put(key, value, options);
        }));
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */
    async get(key, options) {
        return Promise.any(supports(this.routers, 'get')
            .map(async (router) => {
            return router.get(key, options);
        }));
    }
    /**
     * Iterates over all peer routers in parallel to find the given peer
     */
    async findPeer(id, options) {
        if (this.routers.length === 0) {
            throw new CodeError('No peer routers available', 'ERR_NO_ROUTERS_AVAILABLE');
        }
        const self = this;
        const source = merge(...supports(this.routers, 'findPeer')
            .map(router => (async function* () {
            try {
                yield await router.findPeer(id, options);
            }
            catch (err) {
                self.log.error(err);
            }
        })()));
        for await (const peer of source) {
            if (peer == null) {
                continue;
            }
            return peer;
        }
        throw new CodeError('Could not find peer in routing', 'ERR_NOT_FOUND');
    }
    /**
     * Attempt to find the closest peers on the network to the given key
     */
    async *getClosestPeers(key, options = {}) {
        if (this.routers.length === 0) {
            throw new CodeError('No peer routers available', 'ERR_NO_ROUTERS_AVAILABLE');
        }
        for await (const peer of merge(...supports(this.routers, 'getClosestPeers')
            .map(router => router.getClosestPeers(key, options)))) {
            if (peer == null) {
                continue;
            }
            yield peer;
        }
    }
}
function supports(routers, key) {
    return routers.filter(router => router[key] != null);
}
//# sourceMappingURL=routing.js.map