/* eslint-disable no-loop-func */
import { setMaxListeners } from '@libp2p/interface';
import { anySignal } from 'any-signal';
import { Network } from './network.js';
import { PeerWantLists } from './peer-want-lists/index.js';
import { createBitswapSession } from './session.js';
import { Stats } from './stats.js';
import { WantList } from './want-list.js';
/**
 * JavaScript implementation of the Bitswap 'data exchange' protocol
 * used by IPFS.
 */
export class Bitswap {
    log;
    logger;
    stats;
    network;
    blockstore;
    peerWantLists;
    wantList;
    constructor(components, init = {}) {
        this.logger = components.logger;
        this.log = components.logger.forComponent('helia:bitswap');
        this.blockstore = components.blockstore;
        // report stats to libp2p metrics
        this.stats = new Stats(components);
        // the network delivers messages
        this.network = new Network(components, init);
        // handle which blocks we send to peers
        this.peerWantLists = new PeerWantLists({
            ...components,
            network: this.network
        }, init);
        // handle which blocks we ask peers for
        this.wantList = new WantList({
            ...components,
            network: this.network
        }, init);
    }
    createSession(options = {}) {
        return createBitswapSession({
            wantList: this.wantList,
            network: this.network,
            logger: this.logger
        }, options);
    }
    async want(cid, options = {}) {
        const controller = new AbortController();
        const signal = anySignal([controller.signal, options.signal]);
        setMaxListeners(Infinity, controller.signal, signal);
        // find providers and connect to them
        this.network.findAndConnect(cid, {
            ...options,
            signal
        })
            .catch(err => {
            // if the controller was aborted we found the block already so ignore
            // the error
            if (!controller.signal.aborted) {
                this.log.error('error during finding and connect for cid %c', cid, err);
            }
        });
        try {
            const result = await this.wantList.wantBlock(cid, {
                ...options,
                signal
            });
            return result.block;
        }
        finally {
            // since we have the block we can now abort any outstanding attempts to
            // find providers for it
            controller.abort();
            signal.clear();
        }
    }
    /**
     * Sends notifications about the arrival of a block
     */
    async notify(cid, block, options = {}) {
        await Promise.all([
            this.peerWantLists.receivedBlock(cid, options),
            this.wantList.receivedBlock(cid, options)
        ]);
    }
    getWantlist() {
        return [...this.wantList.wants.values()]
            .filter(entry => !entry.cancel)
            .map(entry => ({
            cid: entry.cid,
            priority: entry.priority,
            wantType: entry.wantType
        }));
    }
    getPeerWantlist(peer) {
        return this.peerWantLists.wantListForPeer(peer);
    }
    /**
     * Start the bitswap node
     */
    async start() {
        this.wantList.start();
        await this.network.start();
    }
    /**
     * Stop the bitswap node
     */
    async stop() {
        this.wantList.stop();
        await this.network.stop();
    }
}
//# sourceMappingURL=bitswap.js.map