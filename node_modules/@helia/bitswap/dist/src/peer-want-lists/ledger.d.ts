import { WantType } from '../pb/message.js';
import type { Network } from '../network.js';
import type { ComponentLogger, PeerId } from '@libp2p/interface';
import type { Blockstore } from 'interface-blockstore';
import type { AbortOptions } from 'it-length-prefixed-stream';
import type { CID } from 'multiformats/cid';
export interface LedgerComponents {
    peerId: PeerId;
    blockstore: Blockstore;
    network: Network;
    logger: ComponentLogger;
}
export interface LedgerInit {
    maxSizeReplaceHasWithBlock?: number;
}
export interface PeerWantListEntry {
    /**
     * The CID the peer has requested
     */
    cid: CID;
    /**
     * The priority with which the remote should return the block
     */
    priority: number;
    /**
     * If we want the block or if we want the remote to tell us if they have the
     * block - note if the block is small they'll send it to us anyway.
     */
    wantType: WantType;
    /**
     * Whether the remote should tell us if they have the block or not
     */
    sendDontHave: boolean;
    /**
     * If we don't have the block and we've told them we don't have the block
     */
    sentDontHave?: boolean;
}
export declare class Ledger {
    peerId: PeerId;
    private readonly blockstore;
    private readonly network;
    wants: Map<string, PeerWantListEntry>;
    exchangeCount: number;
    bytesSent: number;
    bytesReceived: number;
    lastExchange?: number;
    private readonly maxSizeReplaceHasWithBlock;
    private readonly log;
    constructor(components: LedgerComponents, init: LedgerInit);
    sentBytes(n: number): void;
    receivedBytes(n: number): void;
    debtRatio(): number;
    sendBlocksToPeer(options?: AbortOptions): Promise<void>;
}
//# sourceMappingURL=ledger.d.ts.map