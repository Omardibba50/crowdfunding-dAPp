import { TypedEventEmitter } from '@libp2p/interface';
import { CID } from 'multiformats/cid';
import { WantType } from './pb/message.js';
import type { BitswapNotifyProgressEvents, MultihashHasherLoader } from './index.js';
import type { BitswapNetworkWantProgressEvents, Network } from './network.js';
import type { ComponentLogger, PeerId, Startable, AbortOptions, Libp2p, TypedEventTarget, Metrics } from '@libp2p/interface';
import type { PeerMap } from '@libp2p/peer-collections';
import type { ProgressOptions } from 'progress-events';
export interface WantListComponents {
    network: Network;
    logger: ComponentLogger;
    libp2p: Libp2p;
    metrics?: Metrics;
}
export interface WantListInit {
    sendMessagesDelay?: number;
    hashLoader?: MultihashHasherLoader;
}
export interface WantListEntry {
    /**
     * The CID we send to the remote
     */
    cid: CID;
    /**
     * The priority with which the remote should return the block
     */
    priority: number;
    /**
     * If we want the block or if we want the remote to tell us if they have the
     * block - note if the block is small they'll send it to us anyway.
     */
    wantType: WantType;
    /**
     * Whether we are cancelling the block want or not
     */
    cancel: boolean;
    /**
     * Whether the remote should tell us if they have the block or not
     */
    sendDontHave: boolean;
}
export interface WantOptions extends AbortOptions, ProgressOptions<BitswapNetworkWantProgressEvents> {
    /**
     * Allow prioritising blocks
     */
    priority?: number;
}
export interface WantBlockResult {
    sender: PeerId;
    cid: CID;
    block: Uint8Array;
}
export interface WantDontHaveResult {
    sender: PeerId;
    cid: CID;
    has: false;
}
export interface WantHaveResult {
    sender: PeerId;
    cid: CID;
    has: true;
    block?: Uint8Array;
}
export type WantPresenceResult = WantDontHaveResult | WantHaveResult;
export interface WantListEvents {
    block: CustomEvent<WantBlockResult>;
    presence: CustomEvent<WantPresenceResult>;
}
export declare class WantList extends TypedEventEmitter<WantListEvents> implements Startable, TypedEventTarget<WantListEvents> {
    /**
     * Tracks what CIDs we've previously sent to which peers
     */
    readonly peers: PeerMap<Set<string>>;
    readonly wants: Map<string, WantListEntry>;
    private readonly network;
    private readonly log;
    private readonly sendMessagesDelay;
    private sendMessagesTimeout?;
    private readonly hashLoader?;
    private sendingMessages?;
    constructor(components: WantListComponents, init?: WantListInit);
    private addEntry;
    private sendMessagesDebounced;
    private sendMessages;
    has(cid: CID): boolean;
    /**
     * Add a CID to the wantlist
     */
    wantSessionPresence(cid: CID, peerId: PeerId, options?: WantOptions): Promise<WantPresenceResult>;
    /**
     * Add a CID to the wantlist
     */
    wantBlock(cid: CID, options?: WantOptions): Promise<WantBlockResult>;
    /**
     * Add a CID to the wantlist
     */
    wantSessionBlock(cid: CID, peerId: PeerId, options?: WantOptions): Promise<WantPresenceResult>;
    /**
     * Invoked when a block has been received from an external source
     */
    receivedBlock(cid: CID, options: ProgressOptions<BitswapNotifyProgressEvents> & AbortOptions): Promise<void>;
    /**
     * Invoked when a message is received from a bitswap peer
     */
    private receiveMessage;
    /**
     * Invoked when the network topology notices a new peer that supports Bitswap
     */
    peerConnected(peerId: PeerId): Promise<void>;
    /**
     * Invoked when the network topology notices peer that supports Bitswap has
     * disconnected
     */
    peerDisconnected(peerId: PeerId): void;
    start(): void;
    stop(): void;
}
//# sourceMappingURL=want-list.d.ts.map