import { keychain } from '@libp2p/keychain';
import { defaultLogger } from '@libp2p/logger';
import { Key } from 'interface-datastore';
import { createLibp2p as create } from 'libp2p';
import { libp2pDefaults } from './libp2p-defaults.js';
export async function createLibp2p(options) {
    const peerId = options.libp2p?.peerId;
    const logger = options.logger ?? defaultLogger();
    const selfKey = new Key('/pkcs8/self');
    let chain;
    // if no peer id was passed, try to load it from the keychain
    if (peerId == null && options.datastore != null) {
        chain = keychain(options.keychain)({
            datastore: options.datastore,
            logger
        });
        if (await options.datastore.has(selfKey)) {
            // load the peer id from the keychain
            options.libp2p = options.libp2p ?? {};
            options.libp2p.peerId = await chain.exportPeerId('self');
        }
    }
    const defaults = libp2pDefaults(options);
    defaults.datastore = defaults.datastore ?? options.datastore;
    options = options ?? {};
    // @ts-expect-error derived ServiceMap is not compatible with ServiceFactoryMap
    const node = await create({
        ...defaults,
        ...options.libp2p,
        start: false
    });
    if (peerId == null && chain != null && !await options.datastore.has(selfKey)) {
        // persist the peer id in the keychain for next time
        await chain.importPeer('self', node.peerId);
    }
    return node;
}
//# sourceMappingURL=libp2p.js.map