/**
 * @packageDocumentation
 *
 * A pushable async generator that waits until the current value is consumed
 * before allowing a new value to be pushed.
 *
 * Useful for when you don't want to keep memory usage under control and/or
 * allow a downstream consumer to dictate how fast data flows through a pipe,
 * but you want to be able to apply a transform to that data.
 *
 * @example
 *
 * ```typescript
 * import { queuelessPushable } from 'it-queueless-pushable'
 *
 * const pushable = queuelessPushable<string>()
 *
 * // run asynchronously
 * Promise.resolve().then(async () => {
 *   // push a value - the returned promise will not resolve until the value is
 *   // read from the pushable
 *   await pushable.push('hello')
 * })
 *
 * // read a value
 * const result = await pushable.next()
 * console.info(result) // { done: false, value: 'hello' }
 * ```
 */
import { type RaceSignalOptions } from 'race-signal';
export interface AbortOptions {
    signal?: AbortSignal;
}
export interface Pushable<T> extends AsyncGenerator<T, void, unknown> {
    /**
     * End the iterable after all values in the buffer (if any) have been yielded. If an
     * error is passed the buffer is cleared immediately and the next iteration will
     * throw the passed error
     */
    end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>;
    /**
     * Push a value into the iterable. Values are yielded from the iterable in the order
     * they are pushed. Values not yet consumed from the iterable are buffered.
     */
    push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>;
}
export declare function queuelessPushable<T>(): Pushable<T>;
//# sourceMappingURL=index.d.ts.map